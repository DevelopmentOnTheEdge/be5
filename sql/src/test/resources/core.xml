<?xml version="1.0" encoding="UTF-8"?>

<testSuite name="core">

  <test name="basic">
    <parser>
      <query><![CDATA[select * from persons]]></query>
      <format dbms="mysql"><![CDATA[SELECT * FROM persons]]></format>
    </parser>
  </test>

  <test name="line-comment">
    <parser>
      <query><![CDATA[select * from persons
   -- line comment]]></query>
      <format dbms="mysql"><![CDATA[SELECT * FROM persons
   -- line comment]]></format>
    </parser>
  </test>

  <test name="backtick">
    <parser>
      <query><![CDATA[select * from `persons`]]></query>
      <format dbms="mysql"><![CDATA[SELECT * FROM `persons`]]></format>
      <format dbms="postgres"><![CDATA[SELECT * FROM "persons"]]></format>
    </parser>
  </test>

  <test name="quote">
    <parser>
      <query><![CDATA[select * from "persons"]]></query>
      <format dbms="mysql"><![CDATA[SELECT * FROM `persons`]]></format>
      <format dbms="postgres"><![CDATA[SELECT * FROM "persons"]]></format>
    </parser>
  </test>

  <test name="column">
    <parser>
      <query><![CDATA[select p.name as "Name" from persons p]]></query>
      <format dbms="mysql"><![CDATA[SELECT p.name AS "Name" FROM persons p]]></format>
    </parser>
  </test>

  <test name="union-distinct">
    <parser>
      <query>
        <![CDATA[select p.name as "Name" from persons p union distinct select c.name as "Name" from companies c]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT p.name AS "Name" FROM persons p UNION DISTINCT SELECT c.name AS "Name" FROM companies c]]></format>
    </parser>
  </test>

  <test name="union">
    <parser>
      <query>
        <![CDATA[select p.name as "Name" from persons p union select c.name as "Name" from companies c]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT p.name AS "Name" FROM persons p UNION SELECT c.name AS "Name" FROM companies c]]></format>
    </parser>
  </test>

  <test name="union-all">
    <parser>
      <query>
        <![CDATA[select p.name as "Name" from persons p union all select c.name as "Name" from companies c]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT p.name AS "Name" FROM persons p UNION ALL SELECT c.name AS "Name" FROM companies c]]></format>
    </parser>
  </test>

  <test name="join-simple">
    <parser>
      <query><![CDATA[select p.name as "Name" from persons p join companies c on c.ID=p.companyID]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT p.name AS "Name" FROM persons p INNER JOIN companies c ON c.ID = p.companyID]]></format>
    </parser>
  </test>

  <test name="and">
    <parser>
      <query><![CDATA[select p.name as "Name" from persons p where isActive == 1 AND p.expires == '']]></query>
      <format dbms="mysql">
        <![CDATA[SELECT p.name AS "Name" FROM persons p WHERE isActive = 1 AND p.expires = '']]></format>
    </parser>
  </test>

  <test name="group-by">
    <parser>
      <query><![CDATA[select p.name as "Name",count(1) from persons p group by p.name]]></query>
      <format dbms="mysql"><![CDATA[SELECT p.name AS "Name", COUNT(1) FROM persons p GROUP BY p.name]]></format>
    </parser>
  </test>

  <test name="group-by-separated">
    <parser>
      <query><![CDATA[select p.name as "Name",count(1) from persons p group/**/by p.name]]></query>
      <format dbms="mysql"><![CDATA[SELECT p.name AS "Name", COUNT(1) FROM persons p GROUP BY p.name]]></format>
    </parser>
  </test>

  <test name="count">
    <parser>
      <query><![CDATA[select p.name as "Name",count(*) from persons p group by p.name]]></query>
      <format dbms="mysql"><![CDATA[SELECT p.name AS "Name", COUNT(*) FROM persons p GROUP BY p.name]]></format>
    </parser>
  </test>

  <test name="having">
    <parser>
      <query><![CDATA[select p.name as "Name",count(*) c from persons p group by p.name having c > 5]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT p.name AS "Name", COUNT(*) c FROM persons p GROUP BY p.name HAVING c > 5]]></format>
    </parser>
  </test>

  <test name="count-distinct">
    <parser>
      <query><![CDATA[select count(distinct a, b) from persons p]]></query>
      <format dbms="mysql"><![CDATA[SELECT COUNT(DISTINCT a, b) FROM persons p]]></format>
    </parser>
  </test>

  <test name="limit">
    <parser>
      <query><![CDATA[select * from persons p limit 10]]></query>
      <format dbms="mysql"><![CDATA[SELECT * FROM persons p LIMIT 10]]></format>
      <format dbms="postgres"><![CDATA[SELECT * FROM persons p LIMIT 10]]></format>
      <format dbms="db2"><![CDATA[SELECT * FROM persons p FETCH FIRST 10 ROWS ONLY]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT TOP 10 * FROM persons p]]></format>
    </parser>
  </test>

  <test name="dual">
    <parser>
      <query><![CDATA[select 'test']]></query>
      <format dbms="mysql"><![CDATA[SELECT 'test' FROM DUAL]]></format>
      <format dbms="oracle"><![CDATA[SELECT 'test' FROM DUAL]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT 'test']]></format>
      <format dbms="postgres"><![CDATA[SELECT 'test']]></format>
      <format dbms="db2"><![CDATA[SELECT 'test' FROM SYSIBM.SYSDUMMY1]]></format>
    </parser>
  </test>

  <test name="dual-where">
    <parser>
      <query><![CDATA[select 1,2 AS "name" where 1<>1]]></query>
      <format dbms="mysql"><![CDATA[SELECT 1, 2 AS "name" FROM DUAL WHERE 1 <> 1]]></format>
      <format dbms="oracle"><![CDATA[SELECT 1, 2 AS "name" FROM DUAL WHERE 1 <> 1]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT 1, 2 AS "name" WHERE 1 <> 1]]></format>
      <format dbms="postgres"><![CDATA[SELECT 1, 2 AS "name" WHERE 1 <> 1]]></format>
      <format dbms="db2"><![CDATA[SELECT 1, 2 AS "name" FROM SYSIBM.SYSDUMMY1 WHERE 1 <> 1]]></format>
    </parser>
  </test>

  <test name="dual2">
    <parser>
      <query><![CDATA[select 'test' from dual]]></query>
      <format dbms="mysql"><![CDATA[SELECT 'test' FROM dual]]></format>
      <format dbms="oracle"><![CDATA[SELECT 'test' FROM dual]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT 'test']]></format>
      <format dbms="postgres"><![CDATA[SELECT 'test']]></format>
      <format dbms="db2"><![CDATA[SELECT 'test' FROM SYSIBM.SYSDUMMY1]]></format>
    </parser>
  </test>

  <test name="concat">
    <parser>
      <query><![CDATA[select concat('[', name, /*comment*/ ']') from table]]></query>
      <format dbms="mysql"><![CDATA[SELECT CONCAT('[', name, /*comment*/ ']') FROM table]]></format>
      <format dbms="oracle"><![CDATA[SELECT '['|| name || /*comment*/ ']' FROM table]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT '['+ name + /*comment*/ ']' FROM table]]></format>
    </parser>
  </test>

  <test name="concat2">
    <parser>
      <query><![CDATA[select '[' || name || /*comment*/ ']' from table]]></query>
      <format dbms="mysql"><![CDATA[SELECT CONCAT('[' , name , /*comment*/ ']') FROM table]]></format>
      <format dbms="oracle"><![CDATA[SELECT '[' || name || /*comment*/ ']' FROM table]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT '[' + name + /*comment*/ ']' FROM table]]></format>
    </parser>
  </test>

  <test name="concat3">
    <parser>
      <query><![CDATA[select ('[' || name || /*comment*/ ']') from table]]></query>
      <format dbms="mysql"><![CDATA[SELECT CONCAT('[' , name , /*comment*/ ']') FROM table]]></format>
      <format dbms="oracle"><![CDATA[SELECT ('[' || name || /*comment*/ ']') FROM table]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT ('[' + name + /*comment*/ ']') FROM table]]></format>
    </parser>
  </test>

  <test name="coalesce-2">
    <parser>
      <query><![CDATA[select coalesce(displayName, name) from table]]></query>
      <format dbms="mysql"><![CDATA[SELECT COALESCE(displayName, name) FROM table]]></format>
      <format dbms="oracle"><![CDATA[SELECT NVL(displayName, name) FROM table]]></format>
    </parser>
  </test>

  <test name="coalesce-3">
    <parser>
      <query><![CDATA[select coalesce(displayName, name, id) from table]]></query>
      <format dbms="mysql"><![CDATA[SELECT COALESCE(displayName, name, id) FROM table]]></format>
      <format dbms="oracle"><![CDATA[SELECT NVL(displayName, NVL( name, id)) FROM table]]></format>
    </parser>
  </test>

  <test name="coalesce-4">
    <parser>
      <query><![CDATA[select coalesce(title /*comment*/, displayName, name, id) from table]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT COALESCE(title /*comment*/, displayName, name, id) FROM table]]></format>
      <format dbms="oracle">
        <![CDATA[SELECT NVL(title /*comment*/, NVL( displayName, NVL( name, id))) FROM table]]></format>
    </parser>
  </test>

  <test name="coalesce-ifnull">
    <parser>
      <query><![CDATA[select ifnull(title /*comment*/, displayName, name, id) from table]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT COALESCE(title /*comment*/, displayName, name, id) FROM table]]></format>
      <format dbms="oracle">
        <![CDATA[SELECT NVL(title /*comment*/, NVL( displayName, NVL( name, id))) FROM table]]></format>
    </parser>
  </test>

  <test name="coalesce-plus">
    <parser>
      <query><![CDATA[select coalesce(amount, 0)+coalesce(amount2, 0) from table]]></query>
      <format dbms="mysql"><![CDATA[SELECT COALESCE(amount, 0)+ COALESCE(amount2, 0) FROM table]]></format>
    </parser>
  </test>

  <test name="substr">
    <parser>
      <query><![CDATA[SELECT ID AS "Code", SUBSTR(name, 1, 60) AS "Name" FROM attributeGroups]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT ID AS "Code", SUBSTRING(name, 1, 60) AS "Name" FROM attributeGroups]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT ID AS "Code", SUBSTR(name, 1, 60) AS "Name" FROM attributeGroups]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT ID AS "Code", SUBSTRING(name, 1, 60) AS "Name" FROM attributeGroups]]></format>
    </parser>
  </test>

  <test name="substr2">
    <parser>
      <query><![CDATA[SELECT ID AS "Code", SUBSTR(name, 5) AS "Name" FROM attributeGroups]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT ID AS "Code", SUBSTRING(name, 5) AS "Name" FROM attributeGroups]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT ID AS "Code", SUBSTR(name, 5) AS "Name" FROM attributeGroups]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT ID AS "Code", SUBSTRING(name, 5, 100000) AS "Name" FROM attributeGroups]]></format>
    </parser>
  </test>

  <test name="len">
    <parser>
      <query><![CDATA[SELECT ID AS "Code", LEN(name) AS "Len" FROM myTable]]></query>
      <format dbms="mysql"><![CDATA[SELECT ID AS "Code", LENGTH(name) AS "Len" FROM myTable]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT ID AS "Code", LEN(name) AS "Len" FROM myTable]]></format>
    </parser>
  </test>

  <test name="char">
    <parser>
      <query><![CDATA[SELECT CHAR(39) AS "Test" FROM myTable]]></query>
      <format dbms="mysql"><![CDATA[SELECT CHAR(39) AS "Test" FROM myTable]]></format>
      <format dbms="postgres"><![CDATA[SELECT CHR(39) AS "Test" FROM myTable]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT CHAR(39) AS "Test" FROM myTable]]></format>
    </parser>
  </test>

  <test name="char-concat">
    <parser>
      <query><![CDATA[SELECT CONCAT(CHAR(39), 'text/plain', CHAR(39)) AS "Test" FROM myTable]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT CONCAT(CHAR(39), 'text/plain', CHAR(39)) AS "Test" FROM myTable]]></format>
      <format dbms="postgres"><![CDATA[SELECT CHR(39)|| 'text/plain'|| CHR(39) AS "Test" FROM myTable]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT CHAR(39)+ 'text/plain'+ CHAR(39) AS "Test" FROM myTable]]></format>
    </parser>
  </test>

  <test name="concat-after-function">
    <parser>
      <query><![CDATA[SELECT ID AS "Code", SUBSTR(name, 1, 60) || '...' AS "Name" FROM myTable]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT ID AS "Code", CONCAT(SUBSTRING(name, 1, 60) , '...') AS "Name" FROM myTable]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT ID AS "Code", SUBSTR(name, 1, 60) || '...' AS "Name" FROM myTable]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT ID AS "Code", SUBSTRING(name, 1, 60) + '...' AS "Name" FROM myTable]]></format>
    </parser>
  </test>

  <test name="concat-before-function">
    <parser>
      <query><![CDATA[SELECT ID AS "Code", 'Name: ' || SUBSTR(name, 1, 60) AS "Name" FROM myTable]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT ID AS "Code", CONCAT('Name: ' , SUBSTRING(name, 1, 60)) AS "Name" FROM myTable]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT ID AS "Code", 'Name: ' || SUBSTR(name, 1, 60) AS "Name" FROM myTable]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT ID AS "Code", 'Name: ' + SUBSTRING(name, 1, 60) AS "Name" FROM myTable]]></format>
    </parser>
  </test>

  <test name="null">
    <parser>
      <query><![CDATA[select null,'test']]></query>
      <format dbms="oracle"><![CDATA[SELECT NULL, 'test' FROM DUAL]]></format>
    </parser>
  </test>

  <test name="exists">
    <parser>
      <query>
        <![CDATA[SELECT c.ID, c.name FROM companies c WHERE EXISTS ( SELECT 1 FROM companies2territories c2t WHERE c2t.companyID = c.ID )]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT c.ID, c.name FROM companies c WHERE EXISTS ( SELECT 1 FROM companies2territories c2t WHERE c2t.companyID = c.ID )]]></format>
    </parser>
  </test>

  <test name="not-equal">
    <parser>
      <query><![CDATA[SELECT 1,2 AS "name" FROM DUAL WHERE 1<>1]]></query>
      <format dbms="oracle"><![CDATA[SELECT 1, 2 AS "name" FROM DUAL WHERE 1 <> 1]]></format>
    </parser>
  </test>

  <test name="is">
    <parser>
      <query>
        <![CDATA[select p.name as "Name" from persons p where p.expires IS NULL AND p.active IS NOT NULL]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT p.name AS "Name" FROM persons p WHERE p.expires IS NULL AND p.active IS NOT NULL]]></format>
    </parser>
  </test>

  <test name="select-value">
    <parser>
      <query><![CDATA[SELECT CODE AS "Code", value AS "Name" FROM cases]]></query>
      <format dbms="oracle"><![CDATA[SELECT CODE AS "Code", value AS "Name" FROM cases]]></format>
    </parser>
  </test>

  <test name="in-list">
    <parser>
      <query>
        <![CDATA[SELECT CODE, name FROM welfareGroups WHERE code IN ('16', '50', '71', '82', '34' )]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT CODE, name FROM welfareGroups WHERE code IN ('16', '50', '71', '82', '34' )]]></format>
    </parser>
  </test>

  <test name="in-select">
    <parser>
      <query>
        <![CDATA[SELECT name AS "CODE", displayName AS "NAME" FROM entities WHERE name IN ( SELECT entity FROM entityStatuses )]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT name AS "CODE", displayName AS "NAME" FROM entities WHERE name IN ( SELECT entity FROM entityStatuses )]]></format>
    </parser>
  </test>

  <test name="upper">
    <parser>
      <query><![CDATA[SELECT
   c.ID AS "Code", c.name AS "Name"
   FROM companies c
   WHERE UPPER(c.name) 
         LIKE '%<parameter:selector strict="no" changeCase="upper" />%']]></query>
      <format dbms="oracle"><![CDATA[SELECT
   c.ID AS "Code", c.name AS "Name"
   FROM companies c
   WHERE UPPER(c.name) 
         LIKE '%<parameter:selector strict="no" changeCase="upper"/>%']]></format>
    </parser>
  </test>

  <test name="case">
    <parser>
      <query><![CDATA[SELECT
        id,
        CASE WHEN x < 0 THEN 'low'
             WHEN x < 10 THEN 'average'
             WHEN x < 20 THEN 'high'
             ELSE 'very high'
        END
    FROM mytable]]></query>
      <format dbms="mysql"><![CDATA[SELECT
        id,
        CASE WHEN x < 0 THEN 'low'
             WHEN x < 10 THEN 'average'
             WHEN x < 20 THEN 'high'
             ELSE 'very high'
        END
    FROM mytable]]></format>
    </parser>
  </test>

  <test name="if">
    <parser>
      <query><![CDATA[SELECT
        id,
        IF(x < 0, 'low', 'high')
    FROM mytable]]></query>
      <format dbms="mysql"><![CDATA[SELECT
        id,
        IF(x < 0, 'low', 'high')
    FROM mytable]]></format>
      <format dbms="oracle"><![CDATA[SELECT
        id,
        CASE WHEN x < 0 THEN 'low' ELSE 'high' END
    FROM mytable]]></format>
    </parser>
  </test>

  <test name="safestr-parsing">
    <parser>
      <query><![CDATA[SELECT * FROM table t WHERE t.field < 'a''b''c']]></query>
      <format dbms="oracle"><![CDATA[SELECT * FROM table t WHERE t.field < 'a''b''c']]></format>
    </parser>
  </test>

  <test name="cast-int-to-varchar1">
    <parser>
      <query><![CDATA[SELECT TO_CHAR(1242.78) FROM table t]]></query>
      <format dbms="oracle"><![CDATA[SELECT TO_CHAR(1242.78) FROM table t]]></format>
      <format dbms="mysql"><![CDATA[SELECT CAST(1242.78 AS CHAR) FROM table t]]></format>
      <format dbms="postgres"><![CDATA[SELECT CAST(1242.78 AS VARCHAR) FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT RTRIM(CAST(1242.78 AS CHAR(254))) FROM table t]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT CAST(1242.78 AS VARCHAR(1000)) FROM table t]]></format>
    </parser>
  </test>

  <test name="cast-int-to-varchar2">
    <parser>
      <query><![CDATA[SELECT CAST(1242.78 AS CHAR) FROM table t]]></query>
      <format dbms="oracle"><![CDATA[SELECT TO_CHAR(1242.78) FROM table t]]></format>
      <format dbms="mysql"><![CDATA[SELECT CAST(1242.78 AS CHAR) FROM table t]]></format>
      <format dbms="postgres"><![CDATA[SELECT CAST(1242.78 AS VARCHAR) FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT RTRIM(CAST(1242.78 AS CHAR(254))) FROM table t]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT CAST(1242.78 AS VARCHAR(1000)) FROM table t]]></format>
    </parser>
  </test>

  <test name="cast-int-to-varchar3">
    <parser>
      <query><![CDATA[SELECT CAST(1242.78 AS VARCHAR) FROM table t]]></query>
      <format dbms="oracle"><![CDATA[SELECT TO_CHAR(1242.78) FROM table t]]></format>
      <format dbms="mysql"><![CDATA[SELECT CAST(1242.78 AS CHAR) FROM table t]]></format>
      <format dbms="postgres"><![CDATA[SELECT CAST(1242.78 AS VARCHAR) FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT RTRIM(CAST(1242.78 AS CHAR(254))) FROM table t]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT CAST(1242.78 AS VARCHAR(1000)) FROM table t]]></format>
    </parser>
  </test>

  <test name="cast-varchar-to-int1">
    <parser>
      <query><![CDATA[SELECT CAST('1210.73' AS BIGINT) FROM table t]]></query>
      <format dbms="oracle"><![CDATA[SELECT TO_NUMBER('1210.73') FROM table t]]></format>
      <format dbms="mysql"><![CDATA[SELECT CAST('1210.73' AS SIGNED) FROM table t]]></format>
      <format dbms="postgres"><![CDATA[SELECT CAST('1210.73' AS BIGINT) FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT CAST('1210.73' AS BIGINT) FROM table t]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT CAST('1210.73' AS BIGINT) FROM table t]]></format>
    </parser>
  </test>

  <test name="cast-varchar-to-int2">
    <parser>
      <query><![CDATA[SELECT TO_NUMBER('1210.73') FROM table t]]></query>
      <format dbms="oracle"><![CDATA[SELECT TO_NUMBER('1210.73') FROM table t]]></format>
      <format dbms="mysql"><![CDATA[SELECT CAST('1210.73' AS SIGNED) FROM table t]]></format>
      <format dbms="postgres"><![CDATA[SELECT CAST('1210.73' AS BIGINT) FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT CAST('1210.73' AS BIGINT) FROM table t]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT CAST('1210.73' AS BIGINT) FROM table t]]></format>
    </parser>
  </test>

  <test name="replace">
    <parser>
      <query><![CDATA[SELECT REPLACE('JACK and JUE', 'J', 'BL') FROM table t]]></query>
      <format dbms="oracle"><![CDATA[SELECT REPLACE('JACK and JUE', 'J', 'BL') FROM table t]]></format>
      <format dbms="mysql"><![CDATA[SELECT REPLACE('JACK and JUE', 'J', 'BL') FROM table t]]></format>
      <format dbms="postgres"><![CDATA[SELECT REPLACE('JACK and JUE', 'J', 'BL') FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT REPLACE('JACK and JUE', 'J', 'BL') FROM table t]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT REPLACE('JACK and JUE', 'J', 'BL') FROM table t]]></format>
    </parser>
  </test>

  <test name="trunc">
    <parser>
      <query><![CDATA[SELECT TRUNC(size/1024, 1) || 'Kb' FROM table t]]></query>
      <format dbms="oracle"><![CDATA[SELECT TRUNC(size / 1024, 1) || 'Kb' FROM table t]]></format>
      <format dbms="mysql"><![CDATA[SELECT CONCAT(TRUNCATE(size / 1024, 1) , 'Kb') FROM table t]]></format>
      <format dbms="postgres"><![CDATA[SELECT TRUNC(size / 1024, 1) || 'Kb' FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT TRUNC(size / 1024, 1) || 'Kb' FROM table t]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT ROUND(size / 1024, 1, 1) + 'Kb' FROM table t]]></format>
    </parser>
  </test>

  <test name="lpad">
    <parser>
      <query><![CDATA[SELECT LPAD('lpad', 8, '0') FROM table t]]></query>
      <format dbms="oracle"><![CDATA[SELECT LPAD('lpad', 8, '0') FROM table t]]></format>
      <format dbms="mysql"><![CDATA[SELECT LPAD('lpad', 8, '0') FROM table t]]></format>
      <format dbms="postgres"><![CDATA[SELECT LPAD('lpad', 8, '0') FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT LPAD('lpad', 8, '0') FROM table t]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT RIGHT(REPLICATE( '0', 8)+'lpad', 8) FROM table t]]></format>
    </parser>
  </test>

  <test name="lpad-nested">
    <parser>
      <query><![CDATA[SELECT LPAD(SUBSTRING(t.name, 6, 4), 8, '0') FROM table t]]></query>
      <format dbms="oracle"><![CDATA[SELECT LPAD(SUBSTR(t.name, 6, 4), 8, '0') FROM table t]]></format>
      <format dbms="mysql"><![CDATA[SELECT LPAD(SUBSTRING(t.name, 6, 4), 8, '0') FROM table t]]></format>
      <format dbms="postgres"><![CDATA[SELECT LPAD(SUBSTR(t.name, 6, 4), 8, '0') FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT LPAD(SUBSTR(t.name, 6, 4), 8, '0') FROM table t]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT RIGHT(REPLICATE( '0', 8)+ SUBSTRING(t.name, 6, 4), 8) FROM table t]]></format>
    </parser>
  </test>

  <test name="join-on-parenthesis">
    <parser>
      <query><![CDATA[SELECT DISTINCT
CASE WHEN sa.recordID IS NOT NULL THEN 'overdued' ELSE 'notoverdued' END AS "overdueStatus"
FROM smevPublicServiceRequests gur
  LEFT JOIN statusAlerts sa ON sa.recordID = ( 'smevPublicServiceRequests.' || CAST(gur.ID AS VARCHAR))]]></query>
      <format dbms="postgres"><![CDATA[SELECT DISTINCT
CASE WHEN sa.recordID IS NOT NULL THEN 'overdued' ELSE 'notoverdued' END AS "overdueStatus"
FROM smevPublicServiceRequests gur
  LEFT JOIN statusAlerts sa ON sa.recordID = ( 'smevPublicServiceRequests.' || CAST(gur.ID AS VARCHAR))]]></format>
    </parser>
  </test>

  <test name="not-in">
    <parser>
      <query><![CDATA[SELECT
rt.code,
rt.name
FROM familyRelationTypes rt
WHERE rt.name NOT IN ( 'Внук', 'Внучка', 'Дочь', 'Жена', 'Зять', 'Муж', 'Невестка', 'Опекаемый/Подопечный',
 'Падчерица', 'Пасынок', 'Правнук', 'Правнучка', 'Приемная дочь', 'Приемный сын', 'Свекр', 'Свекровь', 'Сын', 'Тесть',
 'Теща' )]]></query>
      <format dbms="postgres"><![CDATA[SELECT
rt.code,
rt.name
FROM familyRelationTypes rt
WHERE rt.name NOT IN ( 'Внук', 'Внучка', 'Дочь', 'Жена', 'Зять', 'Муж', 'Невестка', 'Опекаемый/Подопечный',
 'Падчерица', 'Пасынок', 'Правнук', 'Правнучка', 'Приемная дочь', 'Приемный сын', 'Свекр', 'Свекровь', 'Сын', 'Тесть',
 'Теща' )]]></format>
    </parser>
  </test>

  <test name="from-select">
    <parser>
      <query><![CDATA[SELECT * FROM (SELECT * FROM tbl) AS t]]></query>
      <format dbms="postgres"><![CDATA[SELECT * FROM (SELECT * FROM tbl) AS t]]></format>
    </parser>
  </test>

  <test name="current-date">
    <parser>
      <query><![CDATA[SELECT CURRENT_DATE]]></query>
      <format dbms="mysql"><![CDATA[SELECT CURRENT_DATE FROM DUAL]]></format>
      <format dbms="postgres"><![CDATA[SELECT CURRENT_DATE]]></format>
      <format dbms="db2"><![CDATA[SELECT CURRENT_DATE FROM SYSIBM.SYSDUMMY1]]></format>
      <format dbms="oracle"><![CDATA[SELECT SYSDATE FROM DUAL]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT CAST(GETDATE() AS DATE)]]></format>
    </parser>
  </test>

  <test name="current-timestamp">
    <parser>
      <query><![CDATA[SELECT CURRENT_TIMESTAMP]]></query>
      <format dbms="mysql"><![CDATA[SELECT NOW() FROM DUAL]]></format>
      <format dbms="postgres"><![CDATA[SELECT CURRENT_TIMESTAMP]]></format>
      <format dbms="db2"><![CDATA[SELECT CURRENT_TIMESTAMP FROM SYSIBM.SYSDUMMY1]]></format>
      <format dbms="oracle"><![CDATA[SELECT SYSDATE FROM DUAL]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT GETDATE()]]></format>
    </parser>
  </test>

  <test name="now">
    <parser>
      <query><![CDATA[SELECT NOW()]]></query>
      <format dbms="mysql"><![CDATA[SELECT NOW() FROM DUAL]]></format>
      <format dbms="postgres"><![CDATA[SELECT CURRENT_TIMESTAMP]]></format>
      <format dbms="db2"><![CDATA[SELECT CURRENT_TIMESTAMP FROM SYSIBM.SYSDUMMY1]]></format>
      <format dbms="oracle"><![CDATA[SELECT SYSDATE FROM DUAL]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT GETDATE()]]></format>
    </parser>
  </test>

  <test name="nested-in-condition">
    <parser>
      <query><![CDATA[SELECT
-- columns must corresponds to class SMEVNotificationDaemon.Record
    gur.ID AS "gurID",
    ej.ID AS "ejID",
    ej.type AS "ejType",
    child.referenceID AS "welfareRef",
    CASE WHEN p.ID IS NOT NULL THEN ( 
  p.lastName || ' ' || p.firstName || ' ' || 
    CASE WHEN p.middleName IS NOT NULL THEN p.middleName ELSE '' END
                                ) ELSE NULL END AS "whoInserted",
    ej.creationDate___ AS "when",
    msg.ID AS "msgID",
    gur.status AS "status"
FROM governmentUtilityRequests gur
INNER JOIN socialEvents se ON se.referenceID = gur."___ownerID"
INNER JOIN socialEvents child ON se.ID = child.parentID
INNER JOIN entityJournal ej ON ej.referenceID = child.referenceID
    AND ej.creationDate___ > ( SELECT COALESCE( MAX(msgs.creationDate___),gur.creationDate___       )
       FROM governmentUtilityReqMessages msgs
       WHERE msgs.requestID = gur.ID AND msgs.entityJournalID IS NOT NULL AND msgs.delivered = 'yes' )
LEFT JOIN governmentUtilityReqMessages msg ON msg.requestID = gur.ID AND msg.delivered = 'no' AND msg.entityJournalID = ej.ID
LEFT JOIN persons p ON p.userName = ej.whoInserted___
ORDER BY child.referenceID, ej.creationDate___]]></query>
      <format dbms="postgres"><![CDATA[SELECT
-- columns must corresponds to class SMEVNotificationDaemon.Record
    gur.ID AS "gurID",
    ej.ID AS "ejID",
    ej.type AS "ejType",
    child.referenceID AS "welfareRef",
    CASE WHEN p.ID IS NOT NULL THEN ( 
  p.lastName || ' ' || p.firstName || ' ' || 
    CASE WHEN p.middleName IS NOT NULL THEN p.middleName ELSE '' END
                                ) ELSE NULL END AS "whoInserted",
    ej.creationDate___ AS "when",
    msg.ID AS "msgID",
    gur.status AS "status"
FROM governmentUtilityRequests gur
INNER JOIN socialEvents se ON se.referenceID = gur."___ownerID"
INNER JOIN socialEvents child ON se.ID = child.parentID
INNER JOIN entityJournal ej ON ej.referenceID = child.referenceID
    AND ej.creationDate___ > ( SELECT COALESCE( MAX(msgs.creationDate___), gur.creationDate___       )
       FROM governmentUtilityReqMessages msgs
       WHERE msgs.requestID = gur.ID AND msgs.entityJournalID IS NOT NULL AND msgs.delivered = 'yes' )
LEFT JOIN governmentUtilityReqMessages msg ON msg.requestID = gur.ID AND msg.delivered = 'no' AND msg.entityJournalID = ej.ID
LEFT JOIN persons p ON p.userName = ej.whoInserted___
ORDER BY child.referenceID, ej.creationDate___]]></format>
      <format dbms="oracle"><![CDATA[SELECT
-- columns must corresponds to class SMEVNotificationDaemon.Record
    gur.ID AS "gurID",
    ej.ID AS "ejID",
    ej.type AS "ejType",
    child.referenceID AS "welfareRef",
    CASE WHEN p.ID IS NOT NULL THEN ( 
  p.lastName || ' ' || p.firstName || ' ' || 
    CASE WHEN p.middleName IS NOT NULL THEN p.middleName ELSE '' END
                                ) ELSE NULL END AS "whoInserted",
    ej.creationDate___ AS "when",
    msg.ID AS "msgID",
    gur.status AS "status"
FROM governmentUtilityRequests gur
INNER JOIN socialEvents se ON se.referenceID = gur."___ownerID"
INNER JOIN socialEvents child ON se.ID = child.parentID
INNER JOIN entityJournal ej ON ej.referenceID = child.referenceID
    AND ej.creationDate___ > ( SELECT NVL( MAX(msgs.creationDate___), gur.creationDate___       )
       FROM governmentUtilityReqMessages msgs
       WHERE msgs.requestID = gur.ID AND msgs.entityJournalID IS NOT NULL AND msgs.delivered = 'yes' )
LEFT JOIN governmentUtilityReqMessages msg ON msg.requestID = gur.ID AND msg.delivered = 'no' AND msg.entityJournalID = ej.ID
LEFT JOIN persons p ON p.userName = ej.whoInserted___
ORDER BY child.referenceID, ej.creationDate___]]></format>
    </parser>
  </test>


  <test name="groupby-several">
    <parser>
      <query><![CDATA[SELECT
    i.formDate                 AS "formDate",
    i.activeFrom               AS "activeFrom",
    i.activeTo                 AS "activeTo",
    i.preliminary              AS "preliminary",
    SUM(i.countPersons)        AS "count persons",
    SUM(i.countMSP)            AS "count msp",
    SUM(i.sumMSP)              AS "sum msp",
    c.shortName                AS "OPiSV",
    i.whoInserted___           AS "who inserted",
    i.counter                  AS "___counter"
FROM informationMSPPeriod i
INNER JOIN companies c ON c.ID = i.companyID
WHERE i.isDeleted___ = 'no'
GROUP BY i.formDate, i.activeFrom, i.activeTo, i.preliminary, i.whoInserted___,i.counter,c.shortName
ORDER BY i.formDate DESC,  c.shortName]]></query>
      <format dbms="postgres"><![CDATA[SELECT
    i.formDate                 AS "formDate",
    i.activeFrom               AS "activeFrom",
    i.activeTo                 AS "activeTo",
    i.preliminary              AS "preliminary",
    SUM(i.countPersons)        AS "count persons",
    SUM(i.countMSP)            AS "count msp",
    SUM(i.sumMSP)              AS "sum msp",
    c.shortName                AS "OPiSV",
    i.whoInserted___           AS "who inserted",
    i.counter                  AS "___counter"
FROM informationMSPPeriod i
INNER JOIN companies c ON c.ID = i.companyID
WHERE i.isDeleted___ = 'no'
GROUP BY i.formDate, i.activeFrom, i.activeTo, i.preliminary, i.whoInserted___, i.counter, c.shortName
ORDER BY i.formDate DESC,  c.shortName]]></format>
    </parser>
  </test>
  <test name="exists-nested">
    <parser>
      <query><![CDATA[SELECT
      wg.CODE 
         AS "Code", 
      ( wg.CODE || ' ' || COALESCE( wg.shortName,wg.name       )                                  ) 
         AS "Name", 
      wg.applicationRulesTable 
         AS "rulesTable"
FROM welfareGroups wg
WHERE EXISTS 
    ( 
       SELECT 1 FROM applicationRules ar
          INNER JOIN welfareTypes wt ON ar.welfareType = wt.CODE
             INNER JOIN classifications cl ON cl.recordID = ar."___ownerID"
                INNER JOIN categories cat ON cat.ID = cl.categoryID AND cat.publicID = 'QUESTIONNAIRE'
        WHERE wt.welfareGroupCode = wg.CODE AND wg.applicationRulesTable = 'applicationRules'
    UNION 
       SELECT 1 FROM assignmentRules ar
          INNER JOIN welfareTypes wt ON ar.welfareType = wt.CODE
             INNER JOIN classifications cl ON cl.recordID = ar."___ownerID"
                INNER JOIN categories cat ON cat.ID = cl.categoryID AND cat.publicID = 'ASSIGN_QUESTIONNAIRE'
        WHERE wt.welfareGroupCode = wg.CODE AND wg.applicationRulesTable = 'assignmentRules'
    )
ORDER BY COALESCE( wg.shortName,wg.name       )]]></query>
      <format dbms="postgres"><![CDATA[SELECT
      wg.CODE 
         AS "Code", 
      ( wg.CODE || ' ' || COALESCE( wg.shortName, wg.name       )                                  ) 
         AS "Name", 
      wg.applicationRulesTable 
         AS "rulesTable"
FROM welfareGroups wg
WHERE EXISTS 
    ( 
       SELECT 1 FROM applicationRules ar
          INNER JOIN welfareTypes wt ON ar.welfareType = wt.CODE
             INNER JOIN classifications cl ON cl.recordID = ar."___ownerID"
                INNER JOIN categories cat ON cat.ID = cl.categoryID AND cat.publicID = 'QUESTIONNAIRE'
        WHERE wt.welfareGroupCode = wg.CODE AND wg.applicationRulesTable = 'applicationRules'
    UNION 
       SELECT 1 FROM assignmentRules ar
          INNER JOIN welfareTypes wt ON ar.welfareType = wt.CODE
             INNER JOIN classifications cl ON cl.recordID = ar."___ownerID"
                INNER JOIN categories cat ON cat.ID = cl.categoryID AND cat.publicID = 'ASSIGN_QUESTIONNAIRE'
        WHERE wt.welfareGroupCode = wg.CODE AND wg.applicationRulesTable = 'assignmentRules'
    )
ORDER BY COALESCE( wg.shortName, wg.name       )]]></format>
    </parser>
  </test>

  <test name="date-datetime-format1">
    <parser>
      <query>
        <![CDATA[SELECT DATE_FORMAT(date, '%Y-%m-%d'), DATE_FORMAT(date, '%Y-%m-%d %H:%i:%S') FROM table t]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT TO_CHAR(date, 'YYYY-MM-DD'), TO_CHAR(date, 'YYYY-MM-DD HH24:MI:SS') FROM table t]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT DATE_FORMAT(date, '%Y-%m-%d'), DATE_FORMAT(date, '%Y-%m-%d %H:%i:%S') FROM table t]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT TO_CHAR(date, 'YYYY-MM-DD'), TO_CHAR(date, 'YYYY-MM-DD HH24:MI:SS') FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT CAST(date AS CHAR(10)), CAST(date AS CHAR(19)) FROM table t]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT CONVERT(VARCHAR(10), date, 120), CONVERT(VARCHAR(19), date, 120) FROM table t]]></format>
    </parser>
  </test>

  <test name="date-datetime-format2">
    <parser>
      <query>
        <![CDATA[SELECT TO_CHAR(date,'YYYY-MM-DD'), TO_CHAR(date,'YYYY-MM-DD HH24:MI:SS') FROM table t]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT TO_CHAR(date, 'YYYY-MM-DD'), TO_CHAR(date, 'YYYY-MM-DD HH24:MI:SS') FROM table t]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT DATE_FORMAT(date, '%Y-%m-%d'), DATE_FORMAT(date, '%Y-%m-%d %H:%i:%S') FROM table t]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT TO_CHAR(date, 'YYYY-MM-DD'), TO_CHAR(date, 'YYYY-MM-DD HH24:MI:SS') FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT CAST(date AS CHAR(10)), CAST(date AS CHAR(19)) FROM table t]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT CONVERT(VARCHAR(10), date, 120), CONVERT(VARCHAR(19), date, 120) FROM table t]]></format>
    </parser>
  </test>

  <test name="format-date-datetime">
    <parser>
      <query><![CDATA[SELECT FORMAT_DATE(date), FORMAT_DATETIME(date) FROM table t]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT TO_CHAR(date, 'YYYY-MM-DD'), TO_CHAR(date, 'YYYY-MM-DD HH24:MI:SS') FROM table t]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT DATE_FORMAT(date, '%Y-%m-%d'), DATE_FORMAT(date, '%Y-%m-%d %H:%i:%S') FROM table t]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT TO_CHAR(date, 'YYYY-MM-DD'), TO_CHAR(date, 'YYYY-MM-DD HH24:MI:SS') FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT CAST(date AS CHAR(10)), CAST(date AS CHAR(19)) FROM table t]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT CONVERT(VARCHAR(10), date, 120), CONVERT(VARCHAR(19), date, 120) FROM table t]]></format>
    </parser>
  </test>

  <test name="date-format-ru">
    <parser>
      <query>
        <![CDATA[SELECT DATE_FORMAT(a, '%d.%m.%Y'), TO_CHAR(b,'DD.MM.YYYY'), FORMAT_DATE_RUS(c) FROM table t]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT TO_CHAR(a, 'DD.MM.YYYY'), TO_CHAR(b, 'DD.MM.YYYY'), TO_CHAR(c, 'DD.MM.YYYY') FROM table t]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT DATE_FORMAT(a, '%d.%m.%Y'), DATE_FORMAT(b, '%d.%m.%Y'), DATE_FORMAT(c, '%d.%m.%Y') FROM table t]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT TO_CHAR(a, 'DD.MM.YYYY'), TO_CHAR(b, 'DD.MM.YYYY'), TO_CHAR(c, 'DD.MM.YYYY') FROM table t]]></format>
      <format dbms="db2">
        <![CDATA[SELECT VARCHAR_FORMAT(a, 'DD.MM.YYYY'), VARCHAR_FORMAT(b, 'DD.MM.YYYY'), VARCHAR_FORMAT(c, 'DD.MM.YYYY') FROM table t]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT CONVERT(VARCHAR(10), a, 104), CONVERT(VARCHAR(10), b, 104), CONVERT(VARCHAR(10), c, 104) FROM table t]]></format>
    </parser>
  </test>

  <test name="date-format-ru-short">
    <parser>
      <query>
        <![CDATA[SELECT DATE_FORMAT(a, '%d.%m.%y'), TO_CHAR(b,'DD.MM.YY'), FORMAT_DATE_RUS_SHORT(c) FROM table t]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT TO_CHAR(a, 'DD.MM.YY'), TO_CHAR(b, 'DD.MM.YY'), TO_CHAR(c, 'DD.MM.YY') FROM table t]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT DATE_FORMAT(a, '%d.%m.%y'), DATE_FORMAT(b, '%d.%m.%y'), DATE_FORMAT(c, '%d.%m.%y') FROM table t]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT TO_CHAR(a, 'DD.MM.YY'), TO_CHAR(b, 'DD.MM.YY'), TO_CHAR(c, 'DD.MM.YY') FROM table t]]></format>
      <format dbms="db2">
        <![CDATA[SELECT VARCHAR_FORMAT(a, 'DD.MM.YY'), VARCHAR_FORMAT(b, 'DD.MM.YY'), VARCHAR_FORMAT(c, 'DD.MM.YY') FROM table t]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT CONVERT(VARCHAR(8), a, 4), CONVERT(VARCHAR(8), b, 4), CONVERT(VARCHAR(8), c, 4) FROM table t]]></format>
    </parser>
  </test>

  <test name="sum-select">
    <parser>
      <query>
        <![CDATA[select (select SUM(a) FROM x WHERE x.ID=t.ID) + (select SUM(b) FROM y WHERE y.ID=t.ID) FROM t]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT (SELECT SUM(a) FROM x WHERE x.ID = t.ID) + (SELECT SUM(b) FROM y WHERE y.ID = t.ID) FROM t]]></format>
    </parser>
  </test>

  <test name="multiply">
    <parser>
      <query><![CDATA[SELECT CASE WHEN a < 100 * 100 THEN a ELSE b END FROM t]]></query>
      <format dbms="mysql"><![CDATA[SELECT CASE WHEN a < 100 * 100 THEN a ELSE b END FROM t]]></format>
    </parser>
  </test>

  <test name="if-is-null">
    <parser>
      <query><![CDATA[SELECT IF(a IS NULL, b, c) FROM t]]></query>
      <format dbms="mysql"><![CDATA[SELECT IF(a IS NULL, b, c) FROM t]]></format>
    </parser>
  </test>

  <test name="like-concat">
    <parser>
      <query><![CDATA[SELECT
   c.ID AS "Code", ( c.name || ' - ОГРН: ' || c.ogrn ) AS "Name"
FROM companies c
WHERE ( c.name || ' - ОГРН: ' || c.ogrn ) LIKE 'test%']]></query>
      <format dbms="oracle"><![CDATA[SELECT
   c.ID AS "Code", ( c.name || ' - ОГРН: ' || c.ogrn ) AS "Name"
FROM companies c
WHERE ( c.name || ' - ОГРН: ' || c.ogrn ) LIKE 'test%']]></format>
    </parser>
  </test>

  <test name="unary-minus">
    <parser>
      <query><![CDATA[select -1-x FROM t]]></query>
      <format dbms="mysql"><![CDATA[SELECT - 1 - x FROM t]]></format>
    </parser>
  </test>

  <test name="char-cast-as-date">
    <parser>
      <query>
        <![CDATA[SELECT TO_DATE('2003-09-02', 'YYYY-MM-DD'), CAST('2002-09-02' AS DATE), TO_DATE('2001-09-02') FROM table t]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT TO_DATE('2003-09-02', 'YYYY-MM-DD'), TO_DATE('2002-09-02', 'YYYY-MM-DD'), TO_DATE('2001-09-02', 'YYYY-MM-DD') FROM table t]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT CAST('2003-09-02' AS DATE), CAST('2002-09-02' AS DATE), CAST('2001-09-02' AS DATE) FROM table t]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT TO_DATE('2003-09-02', 'YYYY-MM-DD'), TO_DATE('2002-09-02', 'YYYY-MM-DD'), TO_DATE('2001-09-02', 'YYYY-MM-DD') FROM table t]]></format>
      <format dbms="db2"><![CDATA[SELECT '2003-09-02', '2002-09-02', '2001-09-02' FROM table t]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT CONVERT(DATE, '2003-09-02', 120), CONVERT(DATE, '2002-09-02', 120), CONVERT(DATE, '2001-09-02', 120) FROM table t]]></format>
    </parser>
  </test>

  <test name="all-column-ref">
    <parser>
      <query><![CDATA[SELECT groovyHooks.* FROM groovyHooks]]></query>
      <format dbms="mysql"><![CDATA[SELECT groovyHooks.* FROM groovyHooks]]></format>
    </parser>
  </test>

  <test name="between">
    <parser>
      <query><![CDATA[SELECT * FROM table WHERE id BETWEEN 5 AND 6 AND x < 10]]></query>
      <format dbms="mysql"><![CDATA[SELECT * FROM table WHERE id BETWEEN 5 AND 6 AND x < 10]]></format>
    </parser>
  </test>

  <test name="row-number">
    <parser>
      <query><![CDATA[select pensionerminimumincome AS "Pmin",
    count(scpID) as "amount"
   from (
   select

   scp.ID AS scpID,
   scp.pensionerminimumincome,
   ROW_NUMBER() OVER(PARTITION BY s.ID, 'persons.' || CAST(s.personID AS CHAR) ORDER BY scp.CREATIONDATE___ DESC ) AS rn

   FROM subsidies s, assignments a, subsidiesCalcParams scp, entityJournal ej
   WHERE a.referenceID = s."___ownerID"
       AND a.activeFrom <= '2011-01-01'
       AND a.activeTo > '2011-01-01'
       AND scp.journalID = ej.ID
       AND ej.referenceID = s."___ownerID"
   ) sq
   WHERE sq.rn = 1
   GROUP BY sq.pensionerMinimumIncome]]></query>
      <format dbms="postgres"><![CDATA[SELECT pensionerminimumincome AS "Pmin",
    COUNT(scpID) AS "amount"
   FROM (
   SELECT

   scp.ID AS scpID,
   scp.pensionerminimumincome,
   ROW_NUMBER() OVER(PARTITION BY s.ID, 'persons.' || CAST(s.personID AS VARCHAR) ORDER BY scp.CREATIONDATE___ DESC ) AS rn

   FROM subsidies s, assignments a, subsidiesCalcParams scp, entityJournal ej
   WHERE a.referenceID = s."___ownerID"
       AND a.activeFrom <= '2011-01-01'
       AND a.activeTo > '2011-01-01'
       AND scp.journalID = ej.ID
       AND ej.referenceID = s."___ownerID"
   ) sq
   WHERE sq.rn = 1
   GROUP BY sq.pensionerMinimumIncome]]></format>
    </parser>
  </test>

  <test name="year-month-day1">
    <parser>
      <query><![CDATA[SELECT YEAR('2009-05-19'), MONTH('2009-05-19'), DAY('2009-05-19') FROM t]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT TO_NUMBER(TO_CHAR('2009-05-19', 'YYYY')), TO_NUMBER(TO_CHAR('2009-05-19', 'MM')), TO_NUMBER(TO_CHAR('2009-05-19', 'DD')) FROM t]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT YEAR('2009-05-19'), MONTH('2009-05-19'), DAY('2009-05-19') FROM t]]></format>
      <format dbms="db2">
        <![CDATA[SELECT YEAR('2009-05-19'), MONTH('2009-05-19'), DAY('2009-05-19') FROM t]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT DATEPART(YEAR, '2009-05-19'), DATEPART(MONTH, '2009-05-19'), DATEPART(DAY, '2009-05-19') FROM t]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT EXTRACT(YEAR FROM '2009-05-19'), EXTRACT(MONTH FROM '2009-05-19'), EXTRACT(DAY FROM '2009-05-19') FROM t]]></format>
    </parser>
  </test>

  <test name="year-month-day2">
    <parser>
      <query>
        <![CDATA[SELECT EXTRACT(YEAR FROM '2009-05-19'), EXTRACT(MONTH FROM '2009-05-19'), EXTRACT(DAY FROM '2009-05-19') FROM t]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT TO_NUMBER(TO_CHAR( '2009-05-19', 'YYYY')), TO_NUMBER(TO_CHAR( '2009-05-19', 'MM')), TO_NUMBER(TO_CHAR( '2009-05-19', 'DD')) FROM t]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT YEAR( '2009-05-19'), MONTH( '2009-05-19'), DAY( '2009-05-19') FROM t]]></format>
      <format dbms="db2">
        <![CDATA[SELECT YEAR( '2009-05-19'), MONTH( '2009-05-19'), DAY( '2009-05-19') FROM t]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT DATEPART(YEAR, '2009-05-19'), DATEPART(MONTH, '2009-05-19'), DATEPART(DAY, '2009-05-19') FROM t]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT EXTRACT(YEAR FROM '2009-05-19'), EXTRACT(MONTH FROM '2009-05-19'), EXTRACT(DAY FROM '2009-05-19') FROM t]]></format>
    </parser>
  </test>

  <test name="year-month-day-varchar">
    <parser>
      <query><![CDATA[SELECT TO_CHAR(NOW(), 'YYYY'), TO_CHAR(NOW(), 'MM'), TO_CHAR(NOW(), 'DD') FROM t]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT TO_CHAR(SYSDATE, 'YYYY'), TO_CHAR(SYSDATE, 'MM'), TO_CHAR(SYSDATE, 'DD') FROM t]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT DATE_FORMAT(NOW(), '%Y'), DATE_FORMAT(NOW(), '%m'), DATE_FORMAT(NOW(), '%d') FROM t]]></format>
      <format dbms="db2">
        <![CDATA[SELECT VARCHAR_FORMAT(CURRENT_TIMESTAMP, 'YYYY'), VARCHAR_FORMAT(CURRENT_TIMESTAMP, 'MM'), VARCHAR_FORMAT(CURRENT_TIMESTAMP, 'DD') FROM t]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT RIGHT('0'+ RTRIM(YEAR(GETDATE())), 4), RIGHT('0'+ RTRIM(MONTH(GETDATE())), 2), RIGHT('0'+ RTRIM(DAY(GETDATE())), 2) FROM t]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY'), TO_CHAR(CURRENT_TIMESTAMP, 'MM'), TO_CHAR(CURRENT_TIMESTAMP, 'DD') FROM t]]></format>
    </parser>
  </test>

  <test name="and-or-chain">
    <parser>
      <query><![CDATA[SELECT * FROM t WHERE a > 1 AND (p > 2 AND p < 5 OR p > 7 AND p < 10)]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT * FROM t WHERE a > 1 AND (p > 2 AND p < 5 OR p > 7 AND p < 10)]]></format>
    </parser>
  </test>

  <test name="and-not-chain">
    <parser>
      <query><![CDATA[SELECT * FROM t WHERE a > 1 AND (p > 2 AND NOT p < 5 OR NOT p > 7 AND p < 10)]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT * FROM t WHERE a > 1 AND (p > 2 AND NOT p < 5 OR NOT p > 7 AND p < 10)]]></format>
    </parser>
  </test>

  <test name="math-chain">
    <parser>
      <query><![CDATA[SELECT a+b*c+d*e FROM t]]></query>
      <format dbms="oracle"><![CDATA[SELECT a + b * c + d * e FROM t]]></format>
    </parser>
  </test>

  <test name="first-day-of-month-year">
    <parser>
      <query><![CDATA[SELECT DATE_TRUNC('MONTH', x), DATE_TRUNC('YEAR', x) FROM t]]></query>
      <format dbms="oracle"><![CDATA[SELECT TRUNC( x, 'MONTH'), TRUNC( x, 'YEAR') FROM t]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT DATE_FORMAT( x, '%Y-%m-01'), DATE_FORMAT( x, '%Y-01-01') FROM t]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT DATEADD(MONTH, DATEDIFF(MONTH, 0, x), 0), DATEADD(YEAR, DATEDIFF(YEAR, 0, x), 0) FROM t]]></format>
      <format dbms="postgres"><![CDATA[SELECT DATE_TRUNC('MONTH', x), DATE_TRUNC('YEAR', x) FROM t]]></format>
      <format dbms="db2">
        <![CDATA[SELECT  x -(DAY(x)- 1) DAYS,  x -(MONTH(x)- 1) MONTHS -(DAY(x)- 1) DAYS FROM t]]></format>
    </parser>
  </test>

  <test name="charindex">
    <parser>
      <query><![CDATA[SELECT INSTR('Tech on the net', 'e'), POSITION('c' IN 'Tech on the net') FROM t]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT INSTR('Tech on the net', 'e'), INSTR( 'Tech on the net', 'c' ) FROM t]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT INSTR('Tech on the net', 'e'), INSTR( 'Tech on the net', 'c' ) FROM t]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT CHARINDEX( 'e', 'Tech on the net'), CHARINDEX('c' , 'Tech on the net') FROM t]]></format>
      <format dbms="db2">
        <![CDATA[SELECT INSTR('Tech on the net', 'e'), INSTR( 'Tech on the net', 'c' ) FROM t]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT POSITION( 'e' IN 'Tech on the net'), POSITION('c' IN 'Tech on the net') FROM t]]></format>
    </parser>
  </test>

  <test name="add-months">
    <parser>
      <query><![CDATA[SELECT ADD_MONTHS(date, mon) FROM t]]></query>
      <format dbms="oracle"><![CDATA[SELECT ADD_MONTHS(date, mon) FROM t]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT DATEADD(MONTH, mon, date) FROM t]]></format>
      <format dbms="db2"><![CDATA[SELECT (date + mon MONTHS) FROM t]]></format>
      <format dbms="mysql"><![CDATA[SELECT DATE_ADD(date, INTERVAL mon MONTH) FROM t]]></format>
      <format dbms="postgres"><![CDATA[SELECT (date + INTERVAL '1 MONTH'*( mon)) FROM t]]></format>
    </parser>
  </test>

  <test name="add-days">
    <parser>
      <query><![CDATA[SELECT ADD_DAYS(date, days) FROM t]]></query>
      <format dbms="sqlserver"><![CDATA[SELECT DATEADD(DAY, days, date) FROM t]]></format>
      <format dbms="oracle"><![CDATA[SELECT ((date)+( days)) FROM t]]></format>
      <format dbms="db2"><![CDATA[SELECT (date + days DAYS) FROM t]]></format>
      <format dbms="mysql"><![CDATA[SELECT DATE_ADD(date, INTERVAL days DAY) FROM t]]></format>
      <format dbms="postgres"><![CDATA[SELECT (date + INTERVAL '1 DAY'*( days)) FROM t]]></format>
    </parser>
  </test>

  <test name="add-millis">
    <parser>
      <query><![CDATA[SELECT ADD_MILLIS(date, ms) FROM t]]></query>
      <format dbms="oracle"><![CDATA[SELECT (date +( ms / 86400000)) FROM t]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT DATEADD(MILLISECOND, ms, date) FROM t]]></format>
      <format dbms="db2"><![CDATA[SELECT (date +( ms * 1000) MICROSECONDS) FROM t]]></format>
      <format dbms="mysql"><![CDATA[SELECT DATE_ADD(date, INTERVAL ( ms * 1000) MICROSECOND) FROM t]]></format>
      <format dbms="postgres"><![CDATA[SELECT (date + INTERVAL '1 MILLISECOND'*( ms)) FROM t]]></format>
    </parser>
  </test>

  <test name="add-month-formatting">
    <parser>
      <query><![CDATA[SELECT * FROM tbl WHERE a > TO_DATE(d,'YYYY-MM-DD') + (1) * '1 MONTH'::INTERVAL]]></query>
      <format dbms="postgres">
        <![CDATA[SELECT * FROM tbl WHERE a > (TO_DATE(d, 'YYYY-MM-DD')+ INTERVAL '1 MONTH'*(1))]]></format>
    </parser>
  </test>

  <test name="add-month-interval">
    <parser>
      <query><![CDATA[SELECT count(*)
FROM wardPrimaryRegistration wpr, persons p
WHERE wpr.activeFrom <= TO_DATE('<var:___dateRep/>','YYYY-MM-DD')
AND (CAST(CURRENT_DATE AS DATE)  + (-12 * 18 ) * '1 MONTH'::INTERVAL) < p.birthDay
AND wpr.arrangement = '<var:arrangement/>']]></query>
      <format dbms="oracle"><![CDATA[SELECT COUNT(*)
FROM wardPrimaryRegistration wpr, persons p
WHERE wpr.activeFrom <= TO_DATE('<var:___dateRep />', 'YYYY-MM-DD')
AND ADD_MONTHS(TO_DATE(SYSDATE, 'YYYY-MM-DD'), - 12 * 18 )< p.birthDay
AND wpr.arrangement = '<var:arrangement />']]></format>
      <format dbms="sqlserver"><![CDATA[SELECT COUNT(*)
FROM wardPrimaryRegistration wpr, persons p
WHERE wpr.activeFrom <= CONVERT(DATE, '<var:___dateRep />', 120)
AND DATEADD(MONTH, - 12 * 18 , CONVERT(DATE, CAST(GETDATE() AS DATE), 120))< p.birthDay
AND wpr.arrangement = '<var:arrangement />']]></format>
      <format dbms="db2"><![CDATA[SELECT COUNT(*)
FROM wardPrimaryRegistration wpr, persons p
WHERE wpr.activeFrom <= '<var:___dateRep />'
AND (CURRENT_DATE +- 12 * 18 MONTHS)< p.birthDay
AND wpr.arrangement = '<var:arrangement />']]></format>
      <format dbms="mysql"><![CDATA[SELECT COUNT(*)
FROM wardPrimaryRegistration wpr, persons p
WHERE wpr.activeFrom <= CAST('<var:___dateRep />' AS DATE)
AND DATE_ADD(CAST(CURRENT_DATE AS DATE), INTERVAL - 12 * 18 MONTH)< p.birthDay
AND wpr.arrangement = '<var:arrangement />']]></format>
      <format dbms="postgres"><![CDATA[SELECT COUNT(*)
FROM wardPrimaryRegistration wpr, persons p
WHERE wpr.activeFrom <= TO_DATE('<var:___dateRep />', 'YYYY-MM-DD')
AND (TO_DATE(CURRENT_DATE, 'YYYY-MM-DD')+ INTERVAL '1 MONTH'*(- 12 * 18 ))< p.birthDay
AND wpr.arrangement = '<var:arrangement />']]></format>
    </parser>
  </test>

  <test name="cast-as-primary-key">
    <parser>
      <query><![CDATA[SELECT CAST(x AS KEY), TO_KEY(x) FROM t]]></query>
      <format dbms="mysql"><![CDATA[SELECT CAST(x AS UNSIGNED), CAST(x AS UNSIGNED) FROM t]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT CAST(x AS BIGINT), CAST(x AS BIGINT) FROM t]]></format>
      <format dbms="oracle">
        <![CDATA[SELECT CAST(x AS VARCHAR2(15 CHAR)), CAST(x AS VARCHAR2(15 CHAR)) FROM t]]></format>
      <format dbms="db2"><![CDATA[SELECT CAST(x AS BIGINT), CAST(x AS BIGINT) FROM t]]></format>
      <format dbms="postgres"><![CDATA[SELECT CAST(x AS BIGINT), CAST(x AS BIGINT) FROM t]]></format>
    </parser>
  </test>

  <test name="last-day-of-month">
    <parser>
      <query><![CDATA[SELECT LAST_DAY('2003-02-05')]]></query>
      <format dbms="mysql"><![CDATA[SELECT LAST_DAY('2003-02-05') FROM DUAL]]></format>
      <format dbms="oracle"><![CDATA[SELECT LAST_DAY('2003-02-05') FROM DUAL]]></format>
      <format dbms="db2"><![CDATA[SELECT LAST_DAY('2003-02-05') FROM SYSIBM.SYSDUMMY1]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT CONVERT(DATE, DATEADD(DAY, -1, DATEADD(MONTH, DATEDIFF(MONTH, 0, '2003-02-05')+ 1, 0)), 104)]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT CAST(DATE_TRUNC('MONTH', '2003-02-05')+ INTERVAL '1 MONTH'- INTERVAL '1 DAY' AS DATE)]]></format>
    </parser>
  </test>

  <test name="last-day-of-month2">
    <parser>
      <query>
        <![CDATA[SELECT CAST(DATE_TRUNC('MONTH', '2003-02-05')+ INTERVAL '1 MONTH'- INTERVAL '1 DAY' AS DATE)]]></query>
      <format dbms="mysql"><![CDATA[SELECT LAST_DAY( '2003-02-05') FROM DUAL]]></format>
      <format dbms="oracle"><![CDATA[SELECT LAST_DAY( '2003-02-05') FROM DUAL]]></format>
      <format dbms="db2"><![CDATA[SELECT LAST_DAY( '2003-02-05') FROM SYSIBM.SYSDUMMY1]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT CONVERT(DATE, DATEADD(DAY, -1, DATEADD(MONTH, DATEDIFF(MONTH, 0, '2003-02-05')+ 1, 0)), 104)]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT CAST(DATE_TRUNC('MONTH', '2003-02-05')+ INTERVAL '1 MONTH'- INTERVAL '1 DAY' AS DATE)]]></format>
    </parser>
  </test>

  <test name="yeardiff">
    <parser>
      <query><![CDATA[SELECT YEARDIFF(startDate, endDate),
                   EXTRACT(YEAR FROM AGE( endDate, startDate))]]></query>
      <format dbms="mysql"><![CDATA[SELECT TIMESTAMPDIFF(YEAR, startDate, endDate),
                   TIMESTAMPDIFF(YEAR, startDate, endDate) FROM DUAL]]></format>
      <format dbms="oracle"><![CDATA[SELECT FLOOR(MONTHS_BETWEEN( endDate, startDate)/ 12),
                   FLOOR(MONTHS_BETWEEN( endDate, startDate)/ 12) FROM DUAL]]></format>
      <format dbms="db2"><![CDATA[SELECT YEAR( endDate)- YEAR(startDate),
                   YEAR( endDate)- YEAR( startDate) FROM SYSIBM.SYSDUMMY1]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT CASE WHEN RIGHT(CONVERT(VARCHAR(10), startDate, 120), 5)<= RIGHT(CONVERT(VARCHAR(10), endDate, 120), 5) THEN DATEDIFF(yy, startDate, endDate) ELSE DATEDIFF(yy, startDate, endDate)- 1 END,
                   CASE WHEN RIGHT(CONVERT(VARCHAR(10), startDate, 120), 5)<= RIGHT(CONVERT(VARCHAR(10), endDate, 120), 5) THEN DATEDIFF(yy, startDate, endDate) ELSE DATEDIFF(yy, startDate, endDate)- 1 END]]></format>
      <format dbms="postgres"><![CDATA[SELECT EXTRACT(YEAR FROM AGE( endDate, startDate)),
                   EXTRACT(YEAR FROM AGE( endDate, startDate))]]></format>
    </parser>
  </test>

  <test name="limit-offset">
    <parser>
      <query><![CDATA[SELECT * FROM products p ORDER BY buyprice DESC LIMIT 10, 20]]></query>
      <format dbms="mysql"><![CDATA[SELECT * FROM products p ORDER BY buyprice DESC LIMIT 10, 20]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT * FROM products p ORDER BY buyprice DESC LIMIT 20 OFFSET 10]]></format>
      <format dbms="db2">
        <![CDATA[SELECT * FROM (SELECT p.*, ROW_NUMBER() OVER( ORDER BY buyprice DESC) AS rn FROM products p) AS tmp WHERE tmp.rn BETWEEN 10 AND 30]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT * FROM (SELECT p.*, ROW_NUMBER() OVER( ORDER BY buyprice DESC) AS rn FROM products p) AS tmp WHERE tmp.rn BETWEEN 10 AND 30]]></format>
      <format dbms="oracle">
        <![CDATA[SELECT * FROM (SELECT tmp.*, ROWNUM rn FROM (SELECT * FROM products p ORDER BY buyprice DESC) tmp WHERE ROWNUM <= 30) WHERE ROWNUM > 10]]></format>
    </parser>
  </test>

  <test name="limit-offset2">
    <parser>
      <query><![CDATA[SELECT name, address FROM products ORDER BY buyprice DESC LIMIT 10, 20]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT name, address FROM products ORDER BY buyprice DESC LIMIT 10, 20]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT name, address FROM products ORDER BY buyprice DESC LIMIT 20 OFFSET 10]]></format>
      <format dbms="db2">
        <![CDATA[SELECT name, address FROM (SELECT name, address, ROW_NUMBER() OVER( ORDER BY buyprice DESC) AS rn FROM products) AS tmp WHERE tmp.rn BETWEEN 10 AND 30]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT name, address FROM (SELECT name, address, ROW_NUMBER() OVER( ORDER BY buyprice DESC) AS rn FROM products) AS tmp WHERE tmp.rn BETWEEN 10 AND 30]]></format>
      <format dbms="oracle">
        <![CDATA[SELECT name, address FROM (SELECT tmp.*, ROWNUM rn FROM (SELECT name, address FROM products ORDER BY buyprice DESC) tmp WHERE ROWNUM <= 30) WHERE ROWNUM > 10]]></format>
    </parser>
  </test>

  <test name="row-number-order-by">
    <parser>
      <query>
        <![CDATA[SELECT name, address, ROW_NUMBER() OVER( ORDER BY buyprice DESC) AS rn FROM products]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT name, address, ROW_NUMBER() OVER( ORDER BY buyprice DESC) AS rn FROM products]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT name, address, ROW_NUMBER() OVER( ORDER BY buyprice DESC) AS rn FROM products]]></format>
      <format dbms="db2">
        <![CDATA[SELECT name, address, ROW_NUMBER() OVER( ORDER BY buyprice DESC) AS rn FROM products]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT name, address, ROW_NUMBER() OVER( ORDER BY buyprice DESC) AS rn FROM products]]></format>
      <format dbms="oracle">
        <![CDATA[SELECT name, address, ROW_NUMBER() OVER( ORDER BY buyprice DESC) AS rn FROM products]]></format>
    </parser>
  </test>

  <test name="case-when-in">
    <parser>
      <query>
        <![CDATA[SELECT CASE WHEN sap.periodicityType IN ( 'yearly', 'quarterly', 'weekly', 'daily', 'monthly' ) THEN 1 ELSE 0 END FROM DUAL]]></query>
      <format dbms="postgres">
        <![CDATA[SELECT CASE WHEN sap.periodicityType IN ( 'yearly', 'quarterly', 'weekly', 'daily', 'monthly' ) THEN 1 ELSE 0 END]]></format>
      <format dbms="oracle">
        <![CDATA[SELECT CASE WHEN sap.periodicityType IN ( 'yearly', 'quarterly', 'weekly', 'daily', 'monthly' ) THEN 1 ELSE 0 END FROM DUAL]]></format>
    </parser>
  </test>

  <test name="seconddiff">
    <parser>
      <query><![CDATA[SELECT gur.ID, gur.livingSituationCode,
          SECONDDIFF( startDate, endDate ),
          TIMESTAMPDIFF(SECOND, startDate, endDate ),
          EXTRACT(EPOCH FROM (endDate - startDate)) FROM employments e]]></query>
      <format dbms="oracle"><![CDATA[SELECT gur.ID, gur.livingSituationCode,
          TRUNC((CAST( endDate AS DATE)- CAST( startDate AS DATE))* 86400),
          TRUNC((CAST( endDate AS DATE)- CAST( startDate AS DATE))* 86400),
          TRUNC((CAST(endDate AS DATE)- CAST( startDate AS DATE))* 86400) FROM employments e]]></format>
      <format dbms="postgres"><![CDATA[SELECT gur.ID, gur.livingSituationCode,
          EXTRACT(EPOCH FROM ( endDate - startDate)),
          EXTRACT(EPOCH FROM ( endDate - startDate)),
          EXTRACT(EPOCH FROM (endDate - startDate)) FROM employments e]]></format>
      <format dbms="db2"><![CDATA[SELECT gur.ID, gur.livingSituationCode,
          (60 *(60 *(24 * DAYS( endDate )+ HOUR(endDate))+ MINUTE(endDate))+ SECOND(endDate))-(60 *(60 *(24 * DAYS( startDate)+ HOUR(startDate))+ MINUTE(startDate))+ SECOND(startDate)),
          (60 *(60 *(24 * DAYS( endDate )+ HOUR(endDate))+ MINUTE(endDate))+ SECOND(endDate))-(60 *(60 *(24 * DAYS( startDate)+ HOUR(startDate))+ MINUTE(startDate))+ SECOND(startDate)),
          (60 *(60 *(24 * DAYS(endDate )+ HOUR(endDate))+ MINUTE(endDate))+ SECOND(endDate))-(60 *(60 *(24 * DAYS( startDate)+ HOUR(startDate))+ MINUTE(startDate))+ SECOND(startDate)) FROM employments e]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT gur.ID, gur.livingSituationCode,
          CASE WHEN RIGHT(CONVERT(VARCHAR(23), startDate, 121), 3)<= RIGHT(CONVERT(VARCHAR(23), endDate , 121), 3) THEN DATEDIFF(ss, startDate, endDate) ELSE DATEDIFF(ss, startDate, endDate)- 1 END,
          CASE WHEN RIGHT(CONVERT(VARCHAR(23), startDate, 121), 3)<= RIGHT(CONVERT(VARCHAR(23), endDate , 121), 3) THEN DATEDIFF(ss, startDate, endDate) ELSE DATEDIFF(ss, startDate, endDate)- 1 END,
          CASE WHEN RIGHT(CONVERT(VARCHAR(23), startDate, 121), 3)<= RIGHT(CONVERT(VARCHAR(23), endDate , 121), 3) THEN DATEDIFF(ss, startDate, endDate) ELSE DATEDIFF(ss, startDate, endDate)- 1 END FROM employments e]]></format>
      <format dbms="mysql"><![CDATA[SELECT gur.ID, gur.livingSituationCode,
          TIMESTAMPDIFF(SECOND, startDate, endDate ),
          TIMESTAMPDIFF(SECOND, startDate, endDate ),
          TIMESTAMPDIFF(SECOND, startDate, endDate ) FROM employments e]]></format>
    </parser>
  </test>

  <test name="minutediff">
    <parser>
      <query><![CDATA[SELECT gur.ID, gur.livingSituationCode,
          MINUTEDIFF( startDate, endDate ),
          TIMESTAMPDIFF(MINUTE, startDate, endDate ) FROM employments e]]></query>
      <format dbms="oracle"><![CDATA[SELECT gur.ID, gur.livingSituationCode,
          TRUNC((CAST( endDate AS DATE)- CAST( startDate AS DATE))* 1440),
          TRUNC((CAST( endDate AS DATE)- CAST( startDate AS DATE))* 1440) FROM employments e]]></format>
      <format dbms="postgres"><![CDATA[SELECT gur.ID, gur.livingSituationCode,
          FLOOR(EXTRACT(EPOCH FROM ( endDate - startDate))/ 60),
          FLOOR(EXTRACT(EPOCH FROM ( endDate - startDate))/ 60) FROM employments e]]></format>
      <format dbms="db2"><![CDATA[SELECT gur.ID, gur.livingSituationCode,
          (60 *(24 * DAYS( endDate )+ HOUR(endDate))+ MINUTE(endDate))-(60 *(24 * DAYS( startDate)+ HOUR(startDate))+ MINUTE(startDate)),
          (60 *(24 * DAYS( endDate )+ HOUR(endDate))+ MINUTE(endDate))-(60 *(24 * DAYS( startDate)+ HOUR(startDate))+ MINUTE(startDate)) FROM employments e]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT gur.ID, gur.livingSituationCode,
          CASE WHEN RIGHT(CONVERT(VARCHAR(23), startDate, 121), 6)<= RIGHT(CONVERT(VARCHAR(23), endDate , 121), 6) THEN DATEDIFF(mi, startDate, endDate) ELSE DATEDIFF(mi, startDate, endDate)- 1 END,
          CASE WHEN RIGHT(CONVERT(VARCHAR(23), startDate, 121), 6)<= RIGHT(CONVERT(VARCHAR(23), endDate , 121), 6) THEN DATEDIFF(mi, startDate, endDate) ELSE DATEDIFF(mi, startDate, endDate)- 1 END FROM employments e]]></format>
      <format dbms="mysql"><![CDATA[SELECT gur.ID, gur.livingSituationCode,
          TIMESTAMPDIFF(MINUTE, startDate, endDate ),
          TIMESTAMPDIFF(MINUTE, startDate, endDate ) FROM employments e]]></format>
    </parser>
  </test>

  <test name="hourdiff">
    <parser>
      <query>
        <![CDATA[SELECT gur.ID, gur.livingSituationCode, HOURDIFF( startDate, endDate ) FROM employments e]]></query>
      <format dbms="oracle">
        <![CDATA[SELECT gur.ID, gur.livingSituationCode, TRUNC((CAST( endDate AS DATE)- CAST( startDate AS DATE))* 24) FROM employments e]]></format>
      <format dbms="postgres">
        <![CDATA[SELECT gur.ID, gur.livingSituationCode, FLOOR(EXTRACT(EPOCH FROM ( endDate - startDate))/ 3600) FROM employments e]]></format>
      <format dbms="db2">
        <![CDATA[SELECT gur.ID, gur.livingSituationCode, (24 * DAYS( endDate )+ HOUR(endDate))-(24 * DAYS( startDate)+ HOUR(startDate)) FROM employments e]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT gur.ID, gur.livingSituationCode, CASE WHEN RIGHT(CONVERT(VARCHAR(23), startDate, 121), 9)<= RIGHT(CONVERT(VARCHAR(23), endDate , 121), 9) THEN DATEDIFF(hh, startDate, endDate) ELSE DATEDIFF(hh, startDate, endDate)- 1 END FROM employments e]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT gur.ID, gur.livingSituationCode, TIMESTAMPDIFF(HOUR, startDate, endDate ) FROM employments e]]></format>
    </parser>
  </test>

  <test name="daydiff">
    <parser>
      <query><![CDATA[SELECT gur.ID, gur.livingSituationCode, DAYDIFF( startDate, endDate ),
                   EXTRACT(DAY FROM ( endDate - startDate)) FROM employments e]]></query>
      <format dbms="oracle"><![CDATA[SELECT gur.ID, gur.livingSituationCode, TRUNC((CAST( endDate AS DATE)- CAST( startDate AS DATE))),
                   TRUNC((CAST(endDate AS DATE)- CAST( startDate AS DATE))) FROM employments e]]></format>
      <format dbms="postgres"><![CDATA[SELECT gur.ID, gur.livingSituationCode, EXTRACT(DAY FROM ( endDate - startDate)),
                   EXTRACT(DAY FROM (endDate - startDate)) FROM employments e]]></format>
      <format dbms="db2"><![CDATA[SELECT gur.ID, gur.livingSituationCode, DAYS( endDate )- DAYS( startDate),
                   DAYS(endDate )- DAYS( startDate) FROM employments e]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT gur.ID, gur.livingSituationCode, DATEDIFF(dd, startDate, endDate ),
                   DATEDIFF(dd, startDate, endDate ) FROM employments e]]></format>
      <format dbms="mysql"><![CDATA[SELECT gur.ID, gur.livingSituationCode, TIMESTAMPDIFF(DAY, startDate, endDate ),
                   TIMESTAMPDIFF(DAY, startDate, endDate ) FROM employments e]]></format>
    </parser>
  </test>

  <test name="monthdiff">
    <parser>
      <query><![CDATA[SELECT gur.ID, gur.livingSituationCode, MONTHDIFF( startDate, endDate ),
                   12 * EXTRACT(YEAR FROM AGE(endDate, startDate)) + EXTRACT(MONTH FROM AGE( endDate , startDate)),
                   EXTRACT(MONTH FROM AGE( endDate , startDate)) + 12 * EXTRACT(YEAR FROM AGE(endDate, startDate)) FROM employments e]]></query>
      <format dbms="oracle"><![CDATA[SELECT gur.ID, gur.livingSituationCode, MONTHS_BETWEEN(TRUNC( endDate , 'MONTH'), TRUNC( startDate, 'MONTH')),
                   MONTHS_BETWEEN(TRUNC(endDate, 'MONTH'), TRUNC( startDate, 'MONTH')),
                   MONTHS_BETWEEN(TRUNC( endDate , 'MONTH'), TRUNC( startDate, 'MONTH')) FROM employments e]]></format>
      <format dbms="postgres"><![CDATA[SELECT gur.ID, gur.livingSituationCode, EXTRACT(MONTH FROM AGE( endDate , startDate))+ 12 * EXTRACT(YEAR FROM AGE(endDate, startDate)),
                   EXTRACT(MONTH FROM AGE(endDate, startDate))+ 12 * EXTRACT(YEAR FROM AGE(endDate, startDate)),
                   EXTRACT(MONTH FROM AGE( endDate , startDate))+ 12 * EXTRACT(YEAR FROM AGE(endDate, startDate)) FROM employments e]]></format>
      <format dbms="db2"><![CDATA[SELECT gur.ID, gur.livingSituationCode, (12 * YEAR( endDate )+ MONTH(endDate))-(12 * YEAR( startDate)+ MONTH(startDate)),
                   (12 * YEAR(endDate)+ MONTH(endDate))-(12 * YEAR( startDate)+ MONTH(startDate)),
                   (12 * YEAR( endDate )+ MONTH(endDate))-(12 * YEAR( startDate)+ MONTH(startDate)) FROM employments e]]></format>
      -
      <format dbms="sqlserver"><![CDATA[SELECT gur.ID, gur.livingSituationCode, CASE WHEN RIGHT(CONVERT(VARCHAR(10), startDate, 120), 2)<= RIGHT(CONVERT(VARCHAR(10), endDate , 120), 2) THEN DATEDIFF(mm, startDate, endDate) ELSE DATEDIFF(mm, startDate, endDate)- 1 END,
                   CASE WHEN RIGHT(CONVERT(VARCHAR(10), startDate, 120), 2)<= RIGHT(CONVERT(VARCHAR(10), endDate, 120), 2) THEN DATEDIFF(mm, startDate, endDate) ELSE DATEDIFF(mm, startDate, endDate)- 1 END,
                   CASE WHEN RIGHT(CONVERT(VARCHAR(10), startDate, 120), 2)<= RIGHT(CONVERT(VARCHAR(10), endDate , 120), 2) THEN DATEDIFF(mm, startDate, endDate) ELSE DATEDIFF(mm, startDate, endDate)- 1 END FROM employments e]]></format>
      <format dbms="mysql"><![CDATA[SELECT gur.ID, gur.livingSituationCode, TIMESTAMPDIFF(MONTH, startDate, endDate ),
                   TIMESTAMPDIFF(MONTH, startDate, endDate),
                   TIMESTAMPDIFF(MONTH, startDate, endDate ) FROM employments e]]></format>
    </parser>
  </test>

  <test name="mod">
    <parser>
      <query><![CDATA[select x%y, MOD(x, y)]]></query>
      <format dbms="mysql"><![CDATA[SELECT MOD(x, y), MOD(x, y) FROM DUAL]]></format>
      <format dbms="oracle"><![CDATA[SELECT MOD(x, y), MOD(x, y) FROM DUAL]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT x % y, x % y]]></format>
      <format dbms="postgres"><![CDATA[SELECT MOD(x, y), MOD(x, y)]]></format>
      <format dbms="db2"><![CDATA[SELECT MOD(x, y), MOD(x, y) FROM SYSIBM.SYSDUMMY1]]></format>
    </parser>
  </test>

  <test name="monthyear">
    <parser>
      <query><![CDATA[select FORMAT_MONTHYEAR(CURRENT_DATE)]]></query>
      <format dbms="mysql"><![CDATA[SELECT DATE_FORMAT(CURRENT_DATE, '%M %Y') FROM DUAL]]></format>
      <format dbms="oracle"><![CDATA[SELECT TO_CHAR(SYSDATE, 'month YYYY') FROM DUAL]]></format>
      <format dbms="postgres"><![CDATA[SELECT TO_CHAR(CURRENT_DATE, 'month YYYY')]]></format>
      <format dbms="db2">
        <![CDATA[SELECT VARCHAR_FORMAT(CURRENT_DATE, 'month YYYY') FROM SYSIBM.SYSDUMMY1]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT DATENAME(month, CAST(GETDATE() AS DATE))+' '+ CONVERT(VARCHAR(4), CAST(GETDATE() AS DATE), 120)]]></format>
    </parser>
  </test>

  <test name="extra-parens">
    <parser>
      <query><![CDATA[(select test from table where a in (((select b from c))))]]></query>
      <format dbms="mysql"><![CDATA[SELECT test FROM table WHERE a IN (SELECT b FROM c)]]></format>
    </parser>
  </test>

  <test name="special-before-select">
    <parser>
      <query><![CDATA[/*hello*/select test from table]]></query>
      <format dbms="mysql"><![CDATA[/*hello*/ SELECT test FROM table]]></format>
    </parser>
  </test>

  <test name="in-parens">
    <parser>
      <query><![CDATA[SELECT DISTINCT dc.CODE, dc.name
FROM docClasses dc
    INNER JOIN docTypes dt ON dt.class = dc.CODE
WHERE (('SMEV' IN @@current-role-list@@)
   OR ('Reception' IN @@current-role-list@@)
   OR ('Operator' IN @@current-role-list@@)
   OR ('Operator MFC' IN @@current-role-list@@)
   OR ('CareOperator' IN @@current-role-list@@)
   OR ('NursingOperator' IN @@current-role-list@@)
   OR ('CareSupplierRegister' IN @@current-role-list@@)
   OR dc.CODE NOT IN ( 'реестр', 'доход', 'платеж ЖКХ' ))
   AND dt.code IN
   (
       SELECT DISTINCT dt2s.docType
       FROM docTypes2subsystems dt2s, socialSubsystems2roles ss2r
       WHERE dt2s.subsystemCODE IN ( ss2r.subsystemCODE, '00' )
           AND ss2r.role_name IN @@current-role-list@@
   )
ORDER BY name]]></query>
      <format dbms="mysql"><![CDATA[SELECT DISTINCT dc.CODE, dc.name
FROM docClasses dc
    INNER JOIN docTypes dt ON dt.class = dc.CODE
WHERE (('SMEV' IN @@current-role-list@@)
   OR ('Reception' IN @@current-role-list@@)
   OR ('Operator' IN @@current-role-list@@)
   OR ('Operator MFC' IN @@current-role-list@@)
   OR ('CareOperator' IN @@current-role-list@@)
   OR ('NursingOperator' IN @@current-role-list@@)
   OR ('CareSupplierRegister' IN @@current-role-list@@)
   OR dc.CODE NOT IN ( 'реестр', 'доход', 'платеж ЖКХ' ))
   AND dt.code IN
   (
       SELECT DISTINCT dt2s.docType
       FROM docTypes2subsystems dt2s, socialSubsystems2roles ss2r
       WHERE dt2s.subsystemCODE IN ( ss2r.subsystemCODE, '00' )
           AND ss2r.role_name IN @@current-role-list@@
   )
ORDER BY name]]></format>
    </parser>
  </test>

  <test name="rtrim-char">
    <parser>
      <query><![CDATA[SELECT
  ID,
  RTRIM(CHAR(ID)) || ' ' || NAME
FROM pfrDepartments
ORDER BY ID]]></query>
      <format dbms="mysql"><![CDATA[SELECT
  ID,
  CONCAT(RTRIM(CHAR(ID)) , ' ' , NAME)
FROM pfrDepartments
ORDER BY ID]]></format>
      <format dbms="postgres"><![CDATA[SELECT
  ID,
  RTRIM(CHR(ID)) || ' ' || NAME
FROM pfrDepartments
ORDER BY ID]]></format>
    </parser>
  </test>

  <test name="nulls-first">
    <parser>
      <query><![CDATA[SELECT
  rb.title AS "Title",
  rb.whoInserted___ AS "User",
  rb.creationDate___ AS "Time",

    CASE 
      WHEN rb.value IS NULL THEN '{{{Document being created}}}'
      WHEN LENGTH(rb.value) = 0 THEN '{{{Document is empty}}}'
      ELSE  ( '<a href="viewBlob?_t_=reportBlobs&_typeColumn_=contentType&_dataColumn_=value&_filenameColumn_=title&_download_=yes&ID=' || 
            CAST (rb.ID AS VARCHAR) || '">{{{Click}}}</a>'                                  )
    END
    AS "Document"

FROM reportBlobs rb
WHERE rb.companyID = <session:user-companyID default="0" refColumn="companies.ID"/>
ORDER BY


    rb.creationDate___ DESC NULLS FIRST,
rb.whoInserted___]]></query>
      <format dbms="mysql"><![CDATA[SELECT
  rb.title AS "Title",
  rb.whoInserted___ AS "User",
  rb.creationDate___ AS "Time",

    CASE 
      WHEN rb.value IS NULL THEN '{{{Document being created}}}'
      WHEN LENGTH(rb.value) = 0 THEN '{{{Document is empty}}}'
      ELSE CONCAT('<a href="viewBlob?_t_=reportBlobs&_typeColumn_=contentType&_dataColumn_=value&_filenameColumn_=title&_download_=yes&ID=' , 
            CAST(rb.ID AS CHAR) , '">{{{Click}}}</a>')                                  
    END
    AS "Document"

FROM reportBlobs rb
WHERE rb.companyID = <session:user-companyID default="0" refColumn="companies.ID"/>
ORDER BY


    rb.creationDate___ DESC NULLS FIRST,
rb.whoInserted___]]></format>
    </parser>
  </test>

  <test name="full-join">
    <parser>
      <query><![CDATA[SELECT * FROM a FULL OUTER JOIN b ON (a.ID=b.aID)]]></query>
      <format dbms="postgres"><![CDATA[SELECT * FROM a FULL JOIN b ON (a.ID = b.aID)]]></format>
    </parser>
  </test>

  <test name="grouping-sets">
    <parser>
      <query><![CDATA[SELECT
  CASE WHEN GROUPING(provinces.ID) = 1 THEN 'Всего по РФ' ELSE provinces.ID || ' ' || provinces.name END AS "REGION",
  COUNT(invalid.personID) AS "TOTAL",
  COUNT(CASE WHEN invalid.invalidGroup = '1' THEN invalid.personID END ) AS "GROUP|1",
  COUNT(CASE WHEN invalid.invalidGroup = '2' THEN invalid.personID END ) AS "GROUP|2",
  COUNT(CASE WHEN invalid.invalidGroup = '3' THEN invalid.personID END ) AS "GROUP|3",
  COUNT(CASE WHEN invalid.invalidGroup = 'Р' THEN invalid.personID END ) AS "GROUP|Р",
  COUNT(CASE WHEN invalid.invalidGroup IS NULL THEN invalid.personID END ) AS "GROUP|Empty"
FROM provinces provinces
LEFT JOIN persons<parameter:_tcloneid_ default=""/> persons ON provinces.ID = persons.regionCode
LEFT JOIN invalid<parameter:_tcloneid_ default=""/> invalid ON invalid.personID = persons.ID AND COALESCE( invalid.endDate, '9999-12-31' ) > current_date - interval '6 MONTH'
GROUP BY GROUPING SETS( (provinces.ID, provinces.name), () )
ORDER BY GROUPING(provinces.ID) DESC, provinces.ID]]></query>
      <format dbms="postgres"><![CDATA[SELECT
  CASE WHEN GROUPING(provinces.ID) = 1 THEN 'Всего по РФ' ELSE provinces.ID || ' ' || provinces.name END AS "REGION",
  COUNT(invalid.personID) AS "TOTAL",
  COUNT(CASE WHEN invalid.invalidGroup = '1' THEN invalid.personID END ) AS "GROUP|1",
  COUNT(CASE WHEN invalid.invalidGroup = '2' THEN invalid.personID END ) AS "GROUP|2",
  COUNT(CASE WHEN invalid.invalidGroup = '3' THEN invalid.personID END ) AS "GROUP|3",
  COUNT(CASE WHEN invalid.invalidGroup = 'Р' THEN invalid.personID END ) AS "GROUP|Р",
  COUNT(CASE WHEN invalid.invalidGroup IS NULL THEN invalid.personID END ) AS "GROUP|Empty"
FROM provinces provinces
LEFT JOIN persons<parameter:_tcloneid_ default=""/> persons ON provinces.ID = persons.regionCode
LEFT JOIN invalid<parameter:_tcloneid_ default=""/> invalid ON invalid.personID = persons.ID AND COALESCE( invalid.endDate, '9999-12-31' ) > current_date - INTERVAL '6 MONTH'
GROUP BY GROUPING SETS ( (provinces.ID, provinces.name), () )
ORDER BY GROUPING(provinces.ID) DESC, provinces.ID]]></format>
    </parser>
  </test>

  <test name="case-when">
    <parser>
      <query><![CDATA[SELECT
  table_name AS "___ID",
    '<center><b>' || CASE entity WHEN 'fbdp_persons' THEN 'ФБДП' 
                                 WHEN 'persons' THEN 'ФБДП' /*Временно*/
                                 WHEN 'fr_persons' THEN 'ФР'
                                 WHEN 'ptkSpu' THEN 'ПТК СПУ' 
              END || '</center></b>' AS "ENTITY;<grouping />",
    table_name AS "Таблица", '<noFormat />' AS ";Таблица",
    status AS "STATUS",
    startTime AS "START",
    endTime AS "END"
FROM importTableAutomation
ORDER BY entity DESC, table_name]]></query>
      <format dbms="postgres"><![CDATA[SELECT
  table_name AS "___ID",
    '<center><b>' || CASE entity WHEN 'fbdp_persons' THEN 'ФБДП' 
                                 WHEN 'persons' THEN 'ФБДП' /*Временно*/
                                 WHEN 'fr_persons' THEN 'ФР'
                                 WHEN 'ptkSpu' THEN 'ПТК СПУ' 
              END || '</center></b>' AS "ENTITY;<grouping />",
    table_name AS "Таблица", '<noFormat />' AS ";Таблица",
    status AS "STATUS",
    startTime AS "START",
    endTime AS "END"
FROM importTableAutomation
ORDER BY entity DESC, table_name]]></format>
    </parser>
  </test>

  <test name="least">
    <parser>
      <query><![CDATA[SELECT
    x."___sel" AS "___sel",
    COUNT(*) AS "Number of people",
    '<blankNulls />' AS ";Number of people",
    ROUND(COUNT(*) * 100. / <sql exec="pre" distinct="yes" limit="10000" beautifier="com.beanexplorer.web.html.SqlInClauseBeautifier">SELECT COUNT(*) FROM persons</sql> ,2) AS "Percentage of Total",
    '<blankNulls />' AS ";Percentage of Total"
FROM( SELECT LEAST( FLOOR(CAST(EXTRACT(YEAR FROM AGE(NOW(),birthDay)) AS INTEGER)/10),8                     ) AS  "___sel"  FROM persons p ) x
GROUP BY x."___sel"]]></query>
      <format dbms="postgres"><![CDATA[SELECT
    x."___sel" AS "___sel",
    COUNT(*) AS "Number of people",
    '<blankNulls />' AS ";Number of people",
    ROUND(COUNT(*) * 100.0 / <sql exec="pre" distinct="yes" limit="10000" beautifier="com.beanexplorer.web.html.SqlInClauseBeautifier"> SELECT COUNT(*) FROM persons</sql> , 2) AS "Percentage of Total",
    '<blankNulls />' AS ";Percentage of Total"
FROM ( SELECT LEAST( FLOOR(CAST(EXTRACT(YEAR FROM AGE(CURRENT_TIMESTAMP, birthDay)) AS INTEGER)/ 10), 8                     ) AS  "___sel"  FROM persons p ) x
GROUP BY x."___sel"]]></format>
    </parser>
  </test>

  <test name="json">
    <parser>
      <query><![CDATA[SELECT value #>> '{databases,0}' FROM param WHERE name = 'connection']]></query>
      <format dbms="postgres">
        <![CDATA[SELECT value #>> '{databases,0}' FROM param WHERE name = 'connection']]></format>
    </parser>
  </test>

  <test name="pg_func">
    <parser>
      <query><![CDATA[SELECT nspname || '.' || relname AS "Relation",
            pg_size_pretty(pg_relation_size(C.oid)) AS "Size"
          FROM pg_class C
          LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)
          WHERE nspname NOT IN ('pg_catalog', 'information_schema')
          ORDER BY pg_relation_size(C.oid) DESC]]></query>
      <format dbms="postgres"><![CDATA[SELECT nspname || '.' || relname AS "Relation",
            PG_SIZE_PRETTY(PG_RELATION_SIZE(C.oid)) AS "Size"
          FROM pg_class C
          LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)
          WHERE nspname NOT IN ('pg_catalog', 'information_schema')
          ORDER BY PG_RELATION_SIZE(C.oid) DESC]]></format>
    </parser>
  </test>

  <test name="sum_over">
    <parser>
      <query><![CDATA[SELECT nspname || '.' || relname AS "Relation",
            pg_size_pretty(pg_relation_size(C.oid)) AS "Size",
            pg_size_pretty(
                CAST( SUM(pg_relation_size(C.oid))
                OVER(ORDER BY pg_relation_size(C.oid) DESC)
                AS BIGINT)
            ) AS "Sliding sum"
          FROM pg_class C
          LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)
          WHERE nspname NOT IN ('pg_catalog', 'information_schema')
          ORDER BY pg_relation_size(C.oid) DESC]]></query>
      <format dbms="postgres"><![CDATA[SELECT nspname || '.' || relname AS "Relation",
            PG_SIZE_PRETTY(PG_RELATION_SIZE(C.oid)) AS "Size",
            PG_SIZE_PRETTY(
                CAST( SUM(PG_RELATION_SIZE(C.oid)) OVER(ORDER BY PG_RELATION_SIZE(C.oid) DESC) AS BIGINT)
            ) AS "Sliding sum"
          FROM pg_class C
          LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)
          WHERE nspname NOT IN ('pg_catalog', 'information_schema')
          ORDER BY PG_RELATION_SIZE(C.oid) DESC]]></format>
    </parser>
  </test>

  <test name="greatest-least">
    <parser>
      <query><![CDATA[SELECT LEAST(date1, date2), GREATEST(date1, date2) FROM theTable]]></query>
      <format dbms="sqlserver">
        <![CDATA[SELECT (SELECT MIN(V) FROM (VALUES (date1), ( date2)) LEAST (V)), (SELECT MAX(V) FROM (VALUES (date1), ( date2)) GREATEST (V)) FROM theTable]]></format>
    </parser>
  </test>

  <test name="derived-columns">
    <parser>
      <query><![CDATA[SELECT * FROM table JOIN (SELECT * FROM tabl2) AS t2(a, b) ON (t2.a=table.id)]]></query>
      <format dbms="postgres">
        <![CDATA[SELECT * FROM table INNER JOIN (SELECT * FROM tabl2) AS t2 (a, b) ON (t2.a = table.id)]]></format>
    </parser>
  </test>

  <test name="qualified-table-name">
    <parser>
      <query><![CDATA[SELECT
'<center><b>{{{' || q.entity || '}}}</center></b>' AS "ENTITY" , '<grouping />' AS ";ENTITY",
CASE
  WHEN t.table_name IS NOT NULL OR q.table_name IS NULL THEN '<a href="' || q.redirectURL || '">' || COALESCE(lm.message,q.name) || '</a>'
  ELSE COALESCE(lm.message,q.name) END AS "LIST",
q.status AS "STATUS",
q.startTime AS "START",
q.endTime AS "END"
FROM reportListsAutomation q
LEFT JOIN ( SELECT c.relname FROM pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE n.nspname = 'public' ) AS t(table_name) ON t.table_name = LOWER(q.table_name)
LEFT JOIN localizedMessages lm ON lm.entity = q.entity AND lm.topic = 'viewName' AND lm.messageKey = q.name
ORDER BY q.entity, q.name]]></query>
      <format dbms="postgres"><![CDATA[SELECT
'<center><b>{{{' || q.entity || '}}}</center></b>' AS "ENTITY" , '<grouping />' AS ";ENTITY",
CASE
  WHEN t.table_name IS NOT NULL OR q.table_name IS NULL THEN '<a href="' || q.redirectURL || '">' || COALESCE(lm.message, q.name) || '</a>'
  ELSE COALESCE(lm.message, q.name) END AS "LIST",
q.status AS "STATUS",
q.startTime AS "START",
q.endTime AS "END"
FROM reportListsAutomation q
LEFT JOIN ( SELECT c.relname FROM pg_catalog.pg_class c INNER JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE n.nspname = 'public' ) AS t (table_name) ON t.table_name = LOWER(q.table_name)
LEFT JOIN localizedMessages lm ON lm.entity = q.entity AND lm.topic = 'viewName' AND lm.messageKey = q.name
ORDER BY q.entity, q.name]]></format>
    </parser>
  </test>

  <test name="window-frame">
    <parser>
      <query>
        <![CDATA[SELECT ROW_NUMBER() OVER(ROWS BETWEEN a PRECEDING AND b FOLLOWING), ROW_NUMBER() OVER(RANGE CURRENT ROW)]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT ROW_NUMBER() OVER(ROWS BETWEEN a PRECEDING AND b FOLLOWING), ROW_NUMBER() OVER(RANGE CURRENT ROW) FROM DUAL]]></format>
    </parser>
  </test>

  <test name="count-over">
    <parser>
      <query>
        <![CDATA[select p.name as "Name", COUNT(1) OVER ( PARTITION BY cr.ID  ORDER BY cr.ID  ) from persons p group by p.name]]></query>
      <format dbms="mysql">
        <![CDATA[SELECT p.name AS "Name", COUNT(1) OVER( PARTITION BY cr.ID  ORDER BY cr.ID  ) FROM persons p GROUP BY p.name]]></format>
    </parser>
  </test>

  <test name="escape-string">
    <parser>
      <query><![CDATA[SELECT '\', e'\'', 'ab
   \c', E'n\nt\tb\babc<parameter:_tcloneid_ default=""/>ab\nc', E'<parameter:_tcloneid_ default=""/>\n', '\n', E'\_', '\_', E'\%', '\%', E'foo \n bar', 'foo \n bar', E'Dianne\'s horse', 'Dianne''s horse', E'\\', '\\']]></query>
      <format dbms="oracle"><![CDATA[SELECT '\', '''', 'ab
   \c', 'n'|| CHR(10)||'t'|| CHR(9)||'b'|| CHR(8)||'abc<parameter:_tcloneid_ default=""/>ab'|| CHR(10)||'c', '<parameter:_tcloneid_ default=""/>'|| CHR(10), '\n', '_', '\_', '%', '\%', 'foo '|| CHR(10)||' bar', 'foo \n bar', 'Dianne''s horse', 'Dianne''s horse', '\', '\\' FROM DUAL]]></format>
      <format dbms="postgres"><![CDATA[SELECT '\', E'\'', 'ab
   \c', E'n\nt\tb\babc<parameter:_tcloneid_ default=""/>ab\nc', E'<parameter:_tcloneid_ default=""/>\n', '\n', E'\_', '\_', E'\%', '\%', E'foo \n bar', 'foo \n bar', E'Dianne\'s horse', 'Dianne''s horse', E'\\', '\\']]></format>
      <format dbms="mysql"><![CDATA[SELECT '\\', '\'', 'ab
   \\c', 'n\nt\tb\babc<parameter:_tcloneid_ default=""/>ab\\nc', '<parameter:_tcloneid_ default=""/>\n', '\\n', '_', '\_', '%', '\%', 'foo \n bar', 'foo \\n bar', 'Dianne\'s horse', 'Dianne''s horse', '\\', '\\\\' FROM DUAL]]></format>
      <format dbms="db2"><![CDATA[SELECT '\', '''', 'ab
   \c', 'n'|| CHR(10)||'t'|| CHR(9)||'b'|| CHR(8)||'abc<parameter:_tcloneid_ default=""/>ab'|| CHR(10)||'c', '<parameter:_tcloneid_ default=""/>'|| CHR(10), '\n', '_', '\_', '%', '\%', 'foo '|| CHR(10)||' bar', 'foo \n bar', 'Dianne''s horse', 'Dianne''s horse', '\', '\\' FROM SYSIBM.SYSDUMMY1]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT '\', '''', 'ab
   \c', 'n'+ CHAR(10)+'t'+ CHAR(9)+'b'+ CHAR(8)+'abc<parameter:_tcloneid_ default=""/>ab'+ CHAR(10)+'c', '<parameter:_tcloneid_ default=""/>'+ CHAR(10), '\n', '_', '\_', '%', '\%', 'foo '+ CHAR(10)+' bar', 'foo \n bar', 'Dianne''s horse', 'Dianne''s horse', '\', '\\']]></format>
    </parser>
  </test>

  <test name="escape-string2">
    <parser>
      <query><![CDATA[SELECT E'\r\n']]></query>
      <format dbms="oracle"><![CDATA[SELECT CHR(13)|| CHR(10) FROM DUAL]]></format>
      <format dbms="postgres"><![CDATA[SELECT E'\r\n']]></format>
      <format dbms="mysql"><![CDATA[SELECT '\r\n' FROM DUAL]]></format>
      <format dbms="db2"><![CDATA[SELECT CHR(13)|| CHR(10) FROM SYSIBM.SYSDUMMY1]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT CHAR(13)+ CHAR(10)]]></format>
    </parser>
  </test>

  <test name="count-as-identifier">
    <parser>
      <query><![CDATA[SELECT
  ID AS "___ID",
  name AS "NAME",
  count AS "COUNT",
  status AS "STATUS",
  startTime AS "START",
  endTime AS "END"
FROM statusTableAutomation
ORDER BY ID]]></query>
      <format dbms="postgres"><![CDATA[SELECT
  ID AS "___ID",
  name AS "NAME",
  count AS "COUNT",
  status AS "STATUS",
  startTime AS "START",
  endTime AS "END"
FROM statusTableAutomation
ORDER BY ID]]></format>
    </parser>
  </test>

  <test name="cast-in-grouping-set">
    <parser>
      <query><![CDATA[SELECT
  CASE WHEN GROUPING( CAST(EXTRACT(YEAR FROM priv.beginDate) AS INT) ) = 1 THEN 'Всего' ELSE CAST( CAST(EXTRACT(YEAR FROM priv.beginDate) AS INT) AS CHAR(4) ) END 
    AS "Год",
  COUNT( priv.personID ) AS "Инвалидность|Количество записей",
  COUNT( CASE WHEN COALESCE( priv.endDate, '9999-12-31' ) > current_date - interval '6 MONTH' THEN 1 END )
       AS "Инвалидность|Из них действительно"
FROM msePersons mse_persons 
  INNER JOIN msePrivileges priv ON priv.personID = mse_persons.ID

GROUP BY GROUPING SETS( ( CAST(EXTRACT(YEAR FROM priv.beginDate) AS INT) ), () )
ORDER BY GROUPING( CAST(EXTRACT(YEAR FROM priv.beginDate) AS INT) ) DESC]]></query>
      <format dbms="postgres"><![CDATA[SELECT
  CASE WHEN GROUPING( CAST(EXTRACT(YEAR FROM priv.beginDate) AS INT) ) = 1 THEN 'Всего' ELSE CAST( CAST(EXTRACT(YEAR FROM priv.beginDate) AS INT) AS VARCHAR(4)) END 
    AS "Год",
  COUNT( priv.personID ) AS "Инвалидность|Количество записей",
  COUNT( CASE WHEN COALESCE( priv.endDate, '9999-12-31' ) > current_date - INTERVAL '6 MONTH' THEN 1 END )
       AS "Инвалидность|Из них действительно"
FROM msePersons mse_persons 
  INNER JOIN msePrivileges priv ON priv.personID = mse_persons.ID

GROUP BY GROUPING SETS ( ( CAST(EXTRACT(YEAR FROM priv.beginDate) AS INT) ), () )
ORDER BY GROUPING( CAST(EXTRACT(YEAR FROM priv.beginDate) AS INT) ) DESC]]></format>
    </parser>
  </test>

  <test name="bit-operators">
    <parser>
      <query><![CDATA[SELECT 29 | 15, 29 & 15]]></query>
      <format dbms="mysql"><![CDATA[SELECT 29 | 15, 29 & 15 FROM DUAL]]></format>
      <format dbms="postgres"><![CDATA[SELECT 29 | 15, 29 & 15]]></format>
      <format dbms="sqlserver"><![CDATA[SELECT 29 | 15, 29 & 15]]></format>
      <format dbms="oracle"><![CDATA[SELECT 29 + 15 - BITAND(29, 15), BITAND(29 , 15) FROM DUAL]]></format>
      <format dbms="db2"><![CDATA[SELECT BITOR(29 , 15), BITAND(29 , 15) FROM SYSIBM.SYSDUMMY1]]></format>
    </parser>
  </test>

  <test name="with-recursive">
    <parser>
      <query><![CDATA[WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
  )
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part]]></query>
      <format dbms="db2"><![CDATA[WITH included_parts (sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
  )
SELECT sub_part, SUM(quantity) AS total_quantity
FROM included_parts
GROUP BY sub_part]]></format>
      <format dbms="postgres"><![CDATA[WITH RECURSIVE included_parts (sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
  )
SELECT sub_part, SUM(quantity) AS total_quantity
FROM included_parts
GROUP BY sub_part]]></format>
    </parser>
  </test>

  <test name="with">
    <parser>
      <query><![CDATA[WITH regional_sales AS (
        SELECT region, SUM(amount) AS total_sales
        FROM orders
        GROUP BY region
     ), top_regions AS (
        SELECT region
        FROM regional_sales
        WHERE total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)
     )
SELECT region,
       product,
       SUM(quantity) AS product_units,
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product]]></query>
      <format dbms="postgres"><![CDATA[WITH regional_sales AS (
        SELECT region, SUM(amount) AS total_sales
        FROM orders
        GROUP BY region
     ), top_regions AS (
        SELECT region
        FROM regional_sales
        WHERE total_sales > (SELECT SUM(total_sales)/ 10 FROM regional_sales)
     )
SELECT region,
       product,
       SUM(quantity) AS product_units,
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product]]></format>
    </parser>
  </test>

  <test name="right-left">
    <parser>
      <query><![CDATA[SELECT RIGHT(str, 2), LEFT(str, 4)]]></query>
      <format dbms="postgres"><![CDATA[SELECT RIGHT(str, 2), LEFT(str, 4)]]></format>
      <format dbms="oracle"><![CDATA[SELECT SUBSTR(str, - 2), SUBSTR(str, 1, 4) FROM DUAL]]></format>
    </parser>
  </test>

  <test name="date-format">
    <parser>
      <query>
        <![CDATA[SELECT FORMAT_FMDAYMONTH(date), FORMAT_DAYMONTH(date), FORMAT_HOURMINUTE(date), FORMAT_DAY_OF_WEEK(date), FORMAT_YYYYMMDD(date), FORMAT_YYYYMM(date)]]></query>
      <format dbms="postgres">
        <![CDATA[SELECT TO_CHAR(date, 'FMDD.MM'), TO_CHAR(date, 'DD.MM'), TO_CHAR(date, 'HH24:MI'), TO_CHAR(date, 'D'), TO_CHAR(date, 'YYYYMMDD'), TO_CHAR(date, 'YYYYMM')]]></format>
      <format dbms="oracle">
        <![CDATA[SELECT TO_CHAR(date, 'FMDD.MM'), TO_CHAR(date, 'DD.MM'), TO_CHAR(date, 'HH24:MI'), TO_CHAR(date, 'D'), TO_CHAR(date, 'YYYYMMDD'), TO_CHAR(date, 'YYYYMM') FROM DUAL]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT DATE_FORMAT(date, '%e.%c'), DATE_FORMAT(date, '%d.%m'), DATE_FORMAT(date, '%H:%i'), DATE_FORMAT(date, '%w'), DATE_FORMAT(date, '%Y%m%d'), DATE_FORMAT(date, '%Y%m') FROM DUAL]]></format>
      <format dbms="db2">
        <![CDATA[SELECT VARCHAR_FORMAT(date, 'DD.MM'), VARCHAR_FORMAT(date, 'DD.MM'), VARCHAR_FORMAT(date, 'HH24:MI'), VARCHAR_FORMAT(date, 'D'), VARCHAR_FORMAT(date, 'YYYYMMDD'), VARCHAR_FORMAT(date, 'YYYYMM') FROM SYSIBM.SYSDUMMY1]]></format>
      <format dbms="sqlserver">
        <![CDATA[SELECT CONVERT(VARCHAR(5), date, 4), CONVERT(VARCHAR(5), date, 4), CONVERT(VARCHAR(5), date, 114), DATEPART(dw, date), CONVERT(VARCHAR(8), date, 112), CONVERT(VARCHAR(6), date, 112)]]></format>
    </parser>
  </test>

  <test name="in-value-list">
    <parser>
      <query><![CDATA[SELECT
    c.ID AS "___cid",

   COALESCE( c.shortName,c.name       ) AS "name",

   '<sql limit="1" property="up_operLogID">SELECT ol.ID
FROM operationLogs ol, operationQueue oq
WHERE ol.table_name = 'utilityPrivileges' AND ol.operation_name = '<parameter:operation_name />'

  AND oq.operLogID = ol.ID
<if parameter="periodFrom">
  AND oq.creationDate___ BETWEEN '<parameter:periodFrom />' AND '<parameter:periodTo />' 
</if>

  AND EXISTS ( SELECT 1 FROM operationLogParams olp 
       WHERE olp.operLogID = ol.ID AND olp.paramName = 'user-companyID' AND olp.paramValue = '<var:___cid />' )

  AND EXISTS ( SELECT 1 FROM operationLogParams olp 
       WHERE olp.operLogID = ol.ID AND olp.paramName IN ( 'recalcDate', 'date' ) 
                                   AND olp.paramValue 
IN ( '<parameter:calcDate />', 
TO_CHAR(TO_DATE('<parameter:calcDate />','DD.MM.YYYY'),'YYYY-MM-DD') ) )

<if parameter="paymentType">
  AND EXISTS ( SELECT 1 FROM operationLogParams olp 
       WHERE olp.operLogID = ol.ID AND olp.paramName = 'paymentType' AND olp.paramValue = '<parameter:paymentType />' )
</if>
<unless parameter="paymentType">
  AND NOT EXISTS ( SELECT 1 FROM operationLogParams olp 
       WHERE olp.operLogID = ol.ID AND olp.paramName = 'paymentType' )
</unless>
ORDER BY ol.executedAt DESC
</sql>']]></query>
      <format dbms="postgres"><![CDATA[SELECT
    c.ID AS "___cid",

   COALESCE( c.shortName, c.name       ) AS "name",

   '<sql limit="1" property="up_operLogID"> SELECT ol.ID
FROM operationLogs ol, operationQueue oq
WHERE ol.table_name = 'utilityPrivileges' AND ol.operation_name = '<parameter:operation_name />'

  AND oq.operLogID = ol.ID
<if parameter="periodFrom">
  AND oq.creationDate___ BETWEEN '<parameter:periodFrom />' AND '<parameter:periodTo />' 
</if>

  AND EXISTS ( SELECT 1 FROM operationLogParams olp 
       WHERE olp.operLogID = ol.ID AND olp.paramName = 'user-companyID' AND olp.paramValue = '<var:___cid />' )

  AND EXISTS ( SELECT 1 FROM operationLogParams olp 
       WHERE olp.operLogID = ol.ID AND olp.paramName IN ( 'recalcDate', 'date' ) 
                                   AND olp.paramValue 
IN ( '<parameter:calcDate />', 
TO_CHAR(TO_DATE('<parameter:calcDate />', 'DD.MM.YYYY'), 'YYYY-MM-DD')) )

<if parameter="paymentType">
  AND EXISTS ( SELECT 1 FROM operationLogParams olp 
       WHERE olp.operLogID = ol.ID AND olp.paramName = 'paymentType' AND olp.paramValue = '<parameter:paymentType />' )
</if>
<unless parameter="paymentType"> AND NOT EXISTS ( SELECT 1 FROM operationLogParams olp 
       WHERE olp.operLogID = ol.ID AND olp.paramName = 'paymentType' )
</unless>
ORDER BY ol.executedAt DESC
</sql>']]></format>
    </parser>
  </test>

  <test name="not-like">
    <parser>
      <query><![CDATA[select * FROM persons p
    INNER JOIN assignments a ON p.id = a.personID AND a.companyID = <parameter:companyId refColumn="companies.ID"/>
        AND ( a.activeFrom <> a.activeTo OR a.activeTo IS NULL ) AND
        (
            a.activeTo = ( TO_DATE('<parameter:endDate/>','YYYY-MM-DD') + 1 )
                OR a.activeFrom = ( TO_DATE('<parameter:endDate/>','YYYY-MM-DD') + 1 )
        )
        AND ( a.referenceID NOT LIKE 'assignments.%'
            OR NOT EXISTS
            (
              SELECT
                1
              FROM payments pay
                                      INNER JOIN paymentBatches pb ON pay.paymentBatchID = pb.ID
                                                                      AND pb.isOneOff= 'yes'
                                      /*do not move to INNER JOIN statement*/
                                      WHERE pay.assignmentID = a.ID
            ) )
    INNER JOIN assignmentRules ar ON ar.ID = a.assignmentRuleID]]></query>
      <format dbms="postgres"><![CDATA[SELECT * FROM persons p
    INNER JOIN assignments a ON p.id = a.personID AND a.companyID = <parameter:companyId refColumn="companies.ID"/>
        AND ( a.activeFrom <> a.activeTo OR a.activeTo IS NULL ) AND
        (
            a.activeTo = ( TO_DATE('<parameter:endDate />', 'YYYY-MM-DD') + 1 )
                OR a.activeFrom = ( TO_DATE('<parameter:endDate />', 'YYYY-MM-DD') + 1 )
        )
        AND ( a.referenceID NOT LIKE 'assignments.%'
            OR NOT EXISTS
            (
              SELECT
                1
              FROM payments pay
                                      INNER JOIN paymentBatches pb ON pay.paymentBatchID = pb.ID
                                                                      AND pb.isOneOff = 'yes'
                                      /*do not move to INNER JOIN statement*/
                                      WHERE pay.assignmentID = a.ID
            ) )
    INNER JOIN assignmentRules ar ON ar.ID = a.assignmentRuleID]]></format>
    </parser>
  </test>

  <test name="decode">
    <parser>
      <query><![CDATA[select DECODE(job_lvl,1,'level 1',2,'level 2','Unknown level'),
       DECODE(NULL,NULL, 'Null is equal to Null in a decode statement', 'Null is not equal to null in a decode statement'), 
       DECODE(Age, 13,'Thirteen',14,'Fourteen',15,'Fifteen',16,'Sixteen',17,'Seventeen',18,'Eighteen',19,'Nineteen', 'Adult'),
       DECODE(a, NULL, b, a, c, NULL, b)]]></query>
      <format dbms="mysql"><![CDATA[SELECT CASE WHEN job_lvl = 1 THEN 'level 1' WHEN job_lvl = 2 THEN 'level 2' ELSE 'Unknown level' END,
       CASE WHEN NULL IS NULL THEN 'Null is equal to Null in a decode statement' ELSE 'Null is not equal to null in a decode statement' END, 
       CASE WHEN Age = 13 THEN 'Thirteen' WHEN Age = 14 THEN 'Fourteen' WHEN Age = 15 THEN 'Fifteen' WHEN Age = 16 THEN 'Sixteen' WHEN Age = 17 THEN 'Seventeen' WHEN Age = 18 THEN 'Eighteen' WHEN Age = 19 THEN 'Nineteen' ELSE 'Adult' END,
       CASE WHEN a IS NULL THEN b WHEN a = a THEN c WHEN a IS NULL THEN b END FROM DUAL]]></format>
    </parser>
  </test>

  <test name="string_agg">
    <parser>
      <query>
        <![CDATA[SELECT string_agg(x), string_agg(string, separator), string_agg(string, separator Order by string asc)]]></query>
      <format dbms="postgres">
        <![CDATA[SELECT STRING_AGG(x), STRING_AGG(string, separator), STRING_AGG(string, separator ORDER BY string asc)]]></format>
      <format dbms="oracle">
        <![CDATA[SELECT LISTAGG(x) WITHIN GROUP(ORDER BY x), LISTAGG(string, separator) WITHIN GROUP(ORDER BY string), LISTAGG(string, separator) WITHIN GROUP( ORDER BY string asc) FROM DUAL]]></format>
      <format dbms="db2">
        <![CDATA[SELECT LISTAGG(x), LISTAGG(string, separator), LISTAGG(string, separator) WITHIN GROUP( ORDER BY string asc) FROM SYSIBM.SYSDUMMY1]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT GROUP_CONCAT(x), GROUP_CONCAT(string SEPARATOR separator), GROUP_CONCAT(string ORDER BY string asc SEPARATOR separator) FROM DUAL]]></format>
    </parser>
  </test>

  <test name="string_agg-distinct">
    <parser>
      <query>
        <![CDATA[SELECT string_agg(distinct x), string_agg(distinct string, separator Order by string asc)]]></query>
      <format dbms="postgres">
        <![CDATA[SELECT STRING_AGG(DISTINCT x), STRING_AGG(DISTINCT string, separator ORDER BY string asc)]]></format>
      <format dbms="mysql">
        <![CDATA[SELECT GROUP_CONCAT(DISTINCT x), GROUP_CONCAT(DISTINCT string ORDER BY string asc SEPARATOR separator) FROM DUAL]]></format>
    </parser>
  </test>

  <test name="regexp-like">
    <parser>
      <query><![CDATA[SELECT a FROM table WHERE a~'b' AND REGEXP_LIKE(a, 'b')]]></query>
      <format dbms="postgres"><![CDATA[SELECT a FROM table WHERE a ~'b' AND a ~ 'b']]></format>
      <format dbms="mysql"><![CDATA[SELECT a FROM table WHERE a REGEXP 'b' AND a REGEXP 'b']]></format>
      <format dbms="oracle">
        <![CDATA[SELECT a FROM table WHERE REGEXP_LIKE(a, 'b') AND REGEXP_LIKE(a, 'b')]]></format>
    </parser>
  </test>

  <test name="translate">
    <parser>
      <query>
        <![CDATA[SELECT TRANSLATE('this is my string', 'abcdefghijklmnopqrstuvwxyz', 'defghijklmnopqrstuvwxyzabc') encode_string FROM dual]]></query>
      <format dbms="postgres">
        <![CDATA[SELECT TRANSLATE('this is my string', 'abcdefghijklmnopqrstuvwxyz', 'defghijklmnopqrstuvwxyzabc') encode_string]]></format>
      <format dbms="db2">
        <![CDATA[SELECT TRANSLATE('this is my string', 'defghijklmnopqrstuvwxyzabc', 'abcdefghijklmnopqrstuvwxyz') encode_string FROM SYSIBM.SYSDUMMY1]]></format>
    </parser>
  </test>

  <test name="cast-decimal">
    <parser>
      <query>
        <![CDATA[SELECT CAST( COALESCE( pensionSizeRow.value, '0.00' )  AS DECIMAL( 18, 2 ) ) AS pensionSize FROM dual]]></query>
      <format dbms="postgres">
        <![CDATA[SELECT CAST( COALESCE( pensionSizeRow.value, '0.00' ) AS DECIMAL(18, 2)) AS pensionSize]]></format>
      <format dbms="oracle">
        <![CDATA[SELECT TO_NUMBER( NVL( pensionSizeRow.value, '0.00' ), '9999999999999999999.99') AS pensionSize FROM dual]]></format>
    </parser>
  </test>

  <test name="levenshtein">
    <parser>
      <query><![CDATA[SELECT LEVENSHTEIN('GUMBO', 'GAMBOL') from dual]]></query>
      <format dbms="postgres"><![CDATA[SELECT LEVENSHTEIN('GUMBO', 'GAMBOL')]]></format>
      <format dbms="oracle"><![CDATA[SELECT UTL_MATCH.EDIT_DISTANCE('GUMBO', 'GAMBOL') FROM dual]]></format>
    </parser>
  </test>

  <test name="except">
    <parser>
      <query><![CDATA[SELECT product_id FROM inventories MINUS SELECT product_id FROM order_items]]></query>
      <format dbms="postgres">
        <![CDATA[SELECT product_id FROM inventories EXCEPT SELECT product_id FROM order_items]]></format>
      <format dbms="oracle">
        <![CDATA[SELECT product_id FROM inventories MINUS SELECT product_id FROM order_items]]></format>
    </parser>
  </test>

  <test name="sum_DISTINCT">
    <parser>
      <query><![CDATA[SELECT SUM(DISTINCT price) FROM goods]]></query>
      <format dbms="postgres"><![CDATA[SELECT SUM(DISTINCT price) FROM goods]]></format>
    </parser>
  </test>


</testSuite>
