/***************************************************************
                   OPTIONS
***************************************************************/

options 
{
    MULTI = true;
    NODE_DEFAULT_VOID = true;
    STATIC = false;
    UNICODE_INPUT = true;           

    NODE_PREFIX ="Ast"; 
    DEBUG_PARSER = false;

    TRACK_TOKENS=true;
}


/***************************************************************
                   PARSER BEGIN
***************************************************************/

PARSER_BEGIN(SqlParser)
package com.developmentontheedge.sql.model;

import java.io.StringReader;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Vector;

@SuppressWarnings({"unused"})
public class SqlParser extends AbstractParser
{


    /** Default constructor. */
    public SqlParser()
    {    
        this(new StringReader("0"));
    }
}

PARSER_END(SqlParser)


TOKEN_MGR_DECLS : {
    void backup(int n) { input_stream.backup(n); }

    private final Deque<Integer> states = new ArrayDeque<Integer>();
    
    protected void pushState(int state)
    {
        states.push( curLexState );
        SwitchTo( state );
    }
    
    protected void popState()
    {
        SwitchTo( states.poll() );
    }
}

/***************************************************************
                   SKIP
***************************************************************/

<WithinBeTag, WithinBeSubQuery, DEFAULT> SPECIAL_TOKEN :
{
    < (" "|"\t"|"\n"|"\r")+ >
|   <"--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")?>
|   <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")?>
|   <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/***************************************************************
                   TOKENS
***************************************************************/

<WithinBeSubQuery, DEFAULT> TOKEN [IGNORE_CASE]: /* RESERVED WORDS AND LITERALS */
{
    < SELECT:    "select"   >
|   < AS:        "as"       >
|   < FROM:      "from"     >
|   < WHERE:     "where"    >
|   < GROUP:     "group"    >
|   < ORDER:     "order"    >
|   < BY:        "by"       >
|   < ASC:       "asc"      >
|   < DESC:      "desc"     >
|   < HAVING:    "having"   >
|   < UNION:     "union"    >
|   < EXCEPT:    "except"   >
|   < MINUS_LIT: "minus"    >
|   < JOIN:      "join"     >
|   < CASE:      "case"     >
|   < WHEN:      "when"     >
|   < THEN:      "then"     >
|   < ELSE:      "else"     >
|   < END:       "end"      >
|   < NULL:      "null"     >
|   < REPLACEMENT_PARAMETER: "?" >
|   < LIMIT:     "limit"    >
|   < OFFSET:    "offset"   >
|   < LIKE:      "like"     >
|   < NOT_LIKE:  "not like" >
|   < EXISTS:    "exists"   >
|   < USING:     "using"    >
|   < CAST:      "cast"     >
|   < COUNT:     "count"    >
|   < EXTRACT:   "extract"  >
|   < POSITION:  "position" >
|   < OVER:      "over"     >
|   < ROWS:      "rows"     >
|   < RANGE:     "range"    >
|   < FOLLOWING: "following" >
|   < PRECEDING: "preceding" >
|   < PARTITION_BY:  "partition by"  >
|   < GROUPING_SETS: "grouping sets" >
|   < NULLS_FIRST:   "nulls first"   >
|   < NULLS_LAST:    "nulls last"    >
|   < CURRENT_ROW:   "current row"   >
|   < UNBOUNDED_PRECEDING: "unbounded preceding" >
|   < UNBOUNDED_FOLLOWING: "unbounded following" >

|   < INSERT_INTO:  "insert into" >
|   < VALUES:       "values" >
|   < DELETE_FROM:  "delete from" >
|   < UPDATE:       "update" >
|   < SET:          "set" >


|   < WITH:      "with"     >
|   < RECURSIVE: "recursive">

|   < INNER:     "inner"    >
|   < OUTER:     "outer"    >
|   < LEFT:      "left"     >
|   < RIGHT:     "right"    >
|   < FULL:      "full"     >
|   < ON:        "on"       >
|   < INTERVAL:  "interval" >
|   < DOUBLE_COLON:  "::"   >

// set quantifiers
|   < DISTINCT: "distinct"  >
|   < ALL:      "all"       >
}

<WithinBeSubQuery, DEFAULT> TOKEN: /* OPERATORS */
{
    < OP_CONCAT:   "||" >

|   < GT:   ">"  >
|   < LT:   "<"  >
|   < EQ:   "==" >
|   < LE:   "<=" >
|   < GE:   ">=" >
|   < NE:   ("!="|"<>") >
|   < PLUS: "+"  >
|   < MINUS:"-"  >
|   < MUL:  "*"  >
|   < DIV:  "/"  >
|   < NOT:  "!"  >
|   < POWER:"^"  >
|   < MOD:  "%"  >

|   < COMMA:  ","  >
|   < DOT:    "."  >

|   < LEFT_PAREN:   "(" >
|   < RIGHT_PAREN:  ")" >

|   < BIT_OR:  "|" >
|   < BIT_AND: "&" >

|   < REGEXP_MATCH: "~" >
}

<WithinBeSubQuery, DEFAULT> TOKEN [IGNORE_CASE]: /* Boolean expression */
{
    < KW_OR:      "OR"  >
|   < KW_AND:     "AND" >
|   < KW_IS:      "IS"  >
|   < KW_NOT:     "NOT" >
                      
|   < KW_IN:      "IN" > 
|   < KW_BETWEEN: "BETWEEN" > 

}

<WithinBeSubQuery, DEFAULT> TOKEN: /* BE extensions */
{
    < BE_MACRO: "MACRO" >
|   < DBMS_TRANSFORM: "DBMS_TRANSFORM" >
}

<DEFAULT> TOKEN: /* SQL COLUMN */
{
    < BE_SQL_START:    "<sql"    > { pushState(WithinBeTag); }
|   < BE_SQL_END:      "</sql>"  >
|   < BE_SQL_AUTO:     "<sql auto=\"true\"">  
|   < BE_TAG_END:      "/>" >
}

<WithinBeSubQuery> TOKEN :
{
    < BE_SQL_SUB_RESULT: "SubQuery#"  >
|   < BE_SQL_SUB_END:    "</sql>"     > { popState(); }
}

<WithinBeSubQuery, DEFAULT> TOKEN: /* JSON */
{
    < GET_FIELD:	    "->"  >
|   < GET_FIELD_TXT:    "->>" >
|   < EXTRACT_PATH:	    "#>"  >
|   < EXTRACT_PATH_TXT: "#>>" >
}

<WithinBeSubQuery, DEFAULT> TOKEN : /* LITERALS */
{
    < INTEGER_LITERAL:
            <DECIMAL_LITERAL>
    >
|
    < #DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])* >
|
    < FLOATING_POINT_LITERAL:
            (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
            | "." (["0"-"9"])+ (<EXPONENT>)?
            | (["0"-"9"])+ <EXPONENT>
    >
|
    < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| 
    < BACKTICK_QUOTED: "`" ( (~["'","\\","\n","\r"," ","`"])
                           | ("\\" ["n","t","b","r","f","\\","'"] )
                           | "''"
                         )* "`"
    >
| 
    < IDENTIFIER:   <LETTER> (<LETTER>|<DIGIT>)* >
|
    < QUOTE: "\""> 
|
    < DOUBLE_QUOTED: <QUOTE> ( (~["\"","\\","\n","\r"])
                           | ("\\" ["n","t","b","r","f","\\","\""] )
                         )* <QUOTE>
    >
}

<WithinBeTag, WithinBeSubQuery, DEFAULT> TOKEN :
{
    < SINGLE_QUOTE:  "'" > { pushState(WithinString); }
|   < E_SINGLE_QUOTE: "E'" | "e'" > { pushState(WithinEString); }
|   < ASSIGNMENT:  "="  >

|   < #LETTER: ["_", "a"-"z","A"-"Z"] >
|   < #C_LETTER: ["а"-"я","А"-"Я", "ё", "Ё"] >
|   < #DIGIT: ["0"-"9"] >
}

<WithinString, WithinEString, WithinBeSubQuery, WithinBeQuote, DEFAULT> TOKEN :
{
    < BE_PARAMETER_TAG_START:     "<parameter:" > { pushState(WithinBeTag); }
|   < BE_SESSION_TAG_START:       "<session:"   > { pushState(WithinBeTag); }
|   < BE_SQL_VAR_START: 	      "<var:"       > { pushState(WithinBeTag); }
|   < BE_DICTIONARY_START: "<" <IDENTIFIER> ":" > { pushState(WithinBeTag); }

|   < BE_LIST_PLACEHOLDER: ("@@current-role-list@@") >
|   < BE_PLACEHOLDER:  ("@@username@@"|"@@language@@"|"@@context@@"|"@@loggedIn@@"|"@@prevLoggedIn@@"|"@@timestamp@@"|"@@slaveNo@@") >

|   < BE_IF_START:	   "<if "      > { pushState(WithinBeTag); }
|   < BE_IF_END:       "</if>"     >
|   < BE_THEN_START:   "<then>"    >   
|   < BE_THEN_END:     "</then>"   >   
|   < BE_ELSE_START:   "<else>"    >   
|   < BE_ELSE_END:     "</else>"   >
|   < BE_UNLESS_START: "<unless "  > { pushState(WithinBeTag); }
|   < BE_UNLESS_END:   "</unless>" >
}

<WithinString, WithinEString> TOKEN :
{
    < STR_LT:  "<" >  
|   < BE_SQL_SUB_START:  "<sql" > { pushState(WithinBeSubQuery);pushState(WithinBeTag); }
|   < ENDING_SINGLE_QUOTE : "'" > { popState(); }
}

<WithinString> TOKEN :
{
    < STRING_PART :
        ( ~["'", "<"]
        | "''"
        )+
    >
}

<WithinEString> TOKEN :
{
    < E_STRING_PART :
        ( ~["'", "\\", "<"]
        | "''"
        | ( "\\" ~[] )
        )+
    >
}

<WithinBeTag> TOKEN :
{

    < BE_IDENTIFIER : (<LETTER>|<C_LETTER>) (<LETTER>|<C_LETTER>|<DIGIT>|"-"|".")*>
|
    < BE_QUOTE : "\"" > { pushState(WithinBeQuote); }
|     
    < SLASH_TAG_END: "/>" > { popState(); }
| 
    < TAG_END: ">" > { popState(); }
}

<WithinBeQuote> TOKEN :
{
    < QUOTED_PART :
        ( ~["\"","\\","\n","\r","<"]
        | ("\\" ["n","t","b","r","f","\\","\""] )
        )+
    >
|   
    < BE_ENDING_QUOTE : "\"" > { popState(); }
}

/***************************************************************
                   GRAMMAR START
***************************************************************/

AstStart Start() #Start : {}
{
    (
        Query()
      |
        (BeMacro() | BeDbmsTransform())+ [Query()]
    )

    <EOF>
    { return jjtThis; }

}

void Query() #Query :
{}
{
    [WithClause()]
    SelectQuery()
    | Insert()
    | Delete()
    | Update()
}

void SelectQuery():
{}
{
  (
    <LEFT_PAREN> SelectQuery() <RIGHT_PAREN> |
    BeSqlAutoQuery() | BeSql() | SelectExpression()
  )
}
void SelectExpression():
{}
{
    (
      LOOKAHEAD(BeIfStart() <SELECT>)
      BeIfUnlessChainOptional(Mode.CONDITIONAL_SELECT_UNION)
    )*
    Select()
    (
      LOOKAHEAD([ BeIfStart() ] (<UNION> | <EXCEPT> | <MINUS_LIT>))
      (
        BeIfUnlessChainOptional(Mode.CONDITIONAL_UNION)
      | ( UnionClause() | ExceptClause() ) Select()
      )
    )*
}

void NestedQuery() #NestedQuery :
{}
{
    <LEFT_PAREN> Query() <RIGHT_PAREN> 
}

void UnionClause() #Union :
{}
{
        <UNION>
        (<DISTINCT> {jjtThis.setQuantifier(SetQuantifier.DISTINCT); } | <ALL> {jjtThis.setQuantifier(SetQuantifier.ALL); })?
}

void ExceptClause() #Except :
{}
{
        (<EXCEPT> | <MINUS_LIT>)
        (<ALL> {jjtThis.setQuantifier(SetQuantifier.ALL); })?
}

void Select() #Select :
{}
{

     <SELECT>
    (<DISTINCT> {jjtThis.setQuantifier(SetQuantifier.DISTINCT); } | <ALL> {jjtThis.setQuantifier(SetQuantifier.ALL); })?
    SelectList()
    [LOOKAHEAD( [BeIfStart()] <FROM> )
    (FromClause() |
     BeIfUnlessChainOptional(Mode.CONDITIONAL_FROM)
    )]
    [LOOKAHEAD( [BeIfStart()] <WHERE> )
    (WhereClause() |
     BeIfUnlessChainOptional(Mode.CONDITIONAL_WHERE)
    )]
    [LOOKAHEAD( [BeIfStart()] <GROUP> <BY> )
    (GroupByClause() |
     BeIfUnlessChainOptional(Mode.CONDITIONAL_GROUP)
    )]
    [HavingClause()]
    [LOOKAHEAD( [BeIfStart()] <ORDER> <BY> )
    (OrderByClause() |
     BeIfUnlessChainOptional(Mode.CONDITIONAL_ORDER)
    )]
    [LimitClause()] 

}

/***************************************************************
                   With fragment
***************************************************************/

void WithClause() #With :
{}
{
    <WITH> [<RECURSIVE> {jjtThis.setRecursion(true);} ] WithList()
}

void WithList():
{}
{
    WithListElement() (<COMMA> WithListElement())*
}

void WithListElement() #WithListElement :
{}
{
    IdentifierConstant() [WithColumnList()]
    <AS> NestedQuery()
}

void WithColumnList() #ColumnList :
{}
{
    <LEFT_PAREN> FieldReference() (<COMMA> FieldReference())* <RIGHT_PAREN>
}

/***************************************************************
                   SelectList fragment
***************************************************************/

void SelectList() #SelectList :
{}
{
    "*"
  | 
     ( LOOKAHEAD([BeIfStart()] SelectValueType()) SelectValue() )+
}

void SelectValueType() :
{}
{
    <CASE> | <NULL> | <CAST> | <COUNT> | <EXTRACT> | <POSITION> | <GROUPING_SETS> | <LEFT> | <RIGHT> | <INTERVAL> |
    <PLUS> | <MINUS> | <COMMA> | <LEFT_PAREN> | <BE_SQL_START> | <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL> |
    <BACKTICK_QUOTED> | <IDENTIFIER> | <SINGLE_QUOTE> | <E_SINGLE_QUOTE> | <DOUBLE_QUOTED> | <BE_PARAMETER_TAG_START> |
    <BE_SESSION_TAG_START> | <BE_SQL_VAR_START> | <BE_DICTIONARY_START> | <BE_PLACEHOLDER> | <BE_IF_END> | <BE_UNLESS_END>
}

void DerivedColumn() #DerivedColumn :
{
}
{
    [<COMMA> { jjtThis.setPrefixComma(true); }]
    (LOOKAHEAD(3) AllColumnRef() | ValueExpression())
    [LOOKAHEAD(2) [<AS> { jjtThis.setAsToken(true); }] IdentifierConstant()]
    [LOOKAHEAD(2) <COMMA> { jjtThis.setSuffixComma(true); }] 
}

void AllColumnRef() #AllColumnRef :
{
}
{
  IdentifierConstant() <DOT> <MUL> 
}

void SelectValue():
{}
{
    LOOKAHEAD(BeIfStart() SelectValueType())
    (
        {
            pushMode(Mode.CONDITIONAL_COLUMN);
        }
        BeCondition()
        {
            popMode(Mode.CONDITIONAL_COLUMN);
        }
    )
|   DerivedColumn()
}

void PartitionByClause() #PartitionByClause :
{}
{
   <PARTITION_BY> ValueExpression() (<COMMA> ValueExpression())*
}

/***************************************************************
                   Insert
***************************************************************/

void InsertColumnList() #ColumnList :
{}
{
    <LEFT_PAREN> FieldReference() (<COMMA> FieldReference())* <RIGHT_PAREN>
}

void InsertValueList() #InsertValueList :
{}
{
    <VALUES> <LEFT_PAREN> (RowValuePredicand()) (<COMMA> RowValuePredicand())*   <RIGHT_PAREN>
}

void Insert() #Insert :
{}
{
    <INSERT_INTO> TableName() [InsertColumnList()]
    (
     InsertValueList() | SelectExpression()
    )
}

/***************************************************************
                   Delete
***************************************************************/

void Delete() #Delete :
{}
{
    <DELETE_FROM> TableName()
    [LOOKAHEAD( [BeIfStart()] <WHERE> )
    (WhereClause() |
     BeIfUnlessChainOptional(Mode.CONDITIONAL_WHERE)
    )]
}

/***************************************************************
                   Update
***************************************************************/

void UpdateSetComparisonPart() #FunNode(2) : { Token operator; }
{
	operator=UpdateSetCompOperator() RowValuePredicand() { setOperator(jjtThis, operator); }
}

Token UpdateSetCompOperator() : { Token op; }
{
  op = <ASSIGNMENT>     { return op; }
}

void UpdateSetItem() #UpdateSetItem :
{
}
{
  RowValuePredicand()
  (
    UpdateSetComparisonPart()
  )?
}

void UpdateSetList() #UpdateSetList :
{}
{
    <SET> UpdateSetItem() (<COMMA> UpdateSetItem())*
}

void Update() #Update :
{}
{
    <UPDATE> TableName()
    UpdateSetList()
    [LOOKAHEAD( [BeIfStart()] <WHERE> )
    (WhereClause() |
     BeIfUnlessChainOptional(Mode.CONDITIONAL_WHERE)
    )]
}

/***************************************************************
                   BeanExplorer specific tags
***************************************************************/

void BeMacro() #BeMacro :
{
  Token op;
}
{
  <BE_MACRO> op=<IDENTIFIER> <LEFT_PAREN> BeMacroArgumentList(op, jjtThis) <RIGHT_PAREN>
  {
    jjtThis.setFunctionName(op.image);
  }
  ValueExpression()
  <END>
}

void BeMacroArgumentList(Token op, AstBeMacro macro) #BeMacroArgumentList :
{
    int count = 0;
    int defVal = 0;
    boolean hasValue = false;
    boolean prevHasValue = false;
}
{
  (IdentifierConstant() { count++; }
  (<ASSIGNMENT> ValueExpression()
  {
    defVal++;
    prevHasValue = true;
  })?
  (<COMMA> IdentifierConstant() { count++; }
  (<ASSIGNMENT> ValueExpression()
  {
    defVal++;
    hasValue = true;
  })?
  {
    if(!hasValue && prevHasValue)
      error("Invalid argument order: arguments with default values must go to the end of the argument list");
    prevHasValue = hasValue;
    hasValue = false;
  })*)?
  {
    setMacro(op.image, count - defVal, count, macro);
  }
}

void BeDbmsTransform() #BeDbmsTransform :
{
  Token op;
}
{
  <DBMS_TRANSFORM> op=<IDENTIFIER> <LEFT_PAREN> BeDbmsArgumentList(op, jjtThis) <RIGHT_PAREN>
  { jjtThis.setFunctionName(op.image); }
  { pushMode(Mode.DBMS_TRANSFORM); } BeDbmsCase() { popMode(Mode.DBMS_TRANSFORM); }
  <END>
  {
    jjtThis.init();
  }
}

void BeDbmsArgumentList(Token op, AstBeDbmsTransform node) #BeDbmsArgumentList :
{
    int count = 0;
}
{
  (IdentifierConstant() { count++; }
  (<COMMA> IdentifierConstant() { count++; })*)?
  {
    setDbmsTransform(node, op.image, count);
  }
}

void BeDbmsCase() #BeDbmsCase :
{}
{
  <CASE> (BeDbmsWhen() BeDbmsThen())+
}

void BeDbmsWhen() #BeDbmsWhen :
{}
{
  <WHEN> StringConstant() (<COMMA> StringConstant())*
}

void BeDbmsThen() #BeDbmsThen :
{}
{
  <THEN> ( <AS> <KW_IS> { jjtThis.setAsIs(true); } | ValueExpression() )
}

void BeParameterList() #BeParameterList :
{
  Token key = null, value = null;
}
{
    ( BeIdentifier() <ASSIGNMENT> ( BeIdentifier() | BeDoubleQuoted() | StringConstant() ) )*
}

void BeIdentifier() #BeIdentifier :
{
    Token t;
}
{
    t=<BE_IDENTIFIER>
    {
        jjtThis.setValue(t.image);
    }
}

void BeDoubleQuoted() :
{}
{   
    <BE_QUOTE>
    (BeCommonTag() | BeQuotedPart())
    <BE_ENDING_QUOTE>
}

void BeQuotedPart() #BeQuoted :
{
  Token t=null;
}
{
    (t=<QUOTED_PART>)?
    {
        jjtThis.setContent(t == null ? "" : t.image);
    }
}

void BeCommonTag() :
{}
{
        BeParameterTag()
    |   BeSessionTag()
    |   BeVar()
    |   BeDictionary()
}

void BeDictionary() #BeDictionary :
{
  Token dict = null, name = null;
}
{
    dict=<BE_DICTIONARY_START> name=<BE_IDENTIFIER>
	BeParameterList() <SLASH_TAG_END>
	{
		jjtThis.setName(name.image);
		jjtThis.setDictionary(dict.image);
        jjtThis.init();
    }
}

void BeSqlAutoQuery() #BeSqlAuto :
{}
{
  <BE_SQL_AUTO> <BE_TAG_END> [OrderByClause()] 
}

void BeSqlSubQuery() #BeSqlSubQuery :
{}
{
	<BE_SQL_SUB_START>
	BeParameterList()
	<TAG_END>
	(Query() | BeVar() | BeSubQueryResult())?
	<BE_SQL_SUB_END>
	{
      jjtThis.init();
  }
}

void BeSql() #BeSql :
{}
{
	<BE_SQL_START>
  BeParameterList()
  <TAG_END>
	(Query() | BeVar())?
	<BE_SQL_END>
	{
      jjtThis.init();
  }
}

void BeVar() #BeSqlVar :
{
  Token name;
}
{
	<BE_SQL_VAR_START>
	name=<BE_IDENTIFIER>
	BeParameterList()
	<SLASH_TAG_END>
	{
	    jjtThis.setName(name.image);
        jjtThis.init();
    }
}

void BeSubQueryResult() #BeSubQueryResult :
{}
{
    <BE_SQL_SUB_RESULT>
    NumericConstant()
}

void BeSessionTag() #BeSessionTag :
{
  Token name;
}
{
    <BE_SESSION_TAG_START> name=<BE_IDENTIFIER>
    BeParameterList()
    <SLASH_TAG_END>
	{
	    jjtThis.setName(name.image);
        jjtThis.init();
    }  
}

void BeParameterTag() #BeParameterTag :
{
  Token name;
}
{
    <BE_PARAMETER_TAG_START >
    name=<BE_IDENTIFIER>
    BeParameterList()
    <SLASH_TAG_END>
	{
	    jjtThis.setName(name.image);
        jjtThis.init();
    }  
}

// Used for lookahead only
void BeIfStart() :
{}
{
    ((<BE_IF_START>|<BE_UNLESS_START>) (<BE_IDENTIFIER> <ASSIGNMENT> BeValue())* <TAG_END> [<BE_THEN_START>])+
}

void BeValue() :
{}
{
    <BE_QUOTE> (<QUOTED_PART> | BeLACommonTag()) <BE_ENDING_QUOTE>
|   <SINGLE_QUOTE> (<STRING_PART> | <E_STRING_PART> | BeLACommonTag()) <ENDING_SINGLE_QUOTE>
|   <BE_IDENTIFIER>
|   BeLACommonTag()
}

void BeLACommonTag() :
{}
{
    (<BE_DICTIONARY_START> | <BE_SQL_VAR_START> | <BE_SESSION_TAG_START> | <BE_PARAMETER_TAG_START>) <BE_IDENTIFIER> (<BE_IDENTIFIER> <ASSIGNMENT> BeValue())* <SLASH_TAG_END>
}

void BeIf() #BeIf:
{}
{
  	<BE_IF_START>
    BeParameterList()
    <TAG_END>
  	(
		( BeThen() [BeElse()
		{
		  pushMode(Mode.ELSE);
		}] )
		|     
        BeThenImplicit()
    )
    <BE_IF_END>
    {
        jjtThis.init();
    }  
}

void BeUnless() #BeUnless:
{}
{
    <BE_UNLESS_START>
    BeParameterList()
    <TAG_END> (LOOKAHEAD(<BE_IF_START> | <BE_UNLESS_START>) (BeCondition())+ | BeAction()) <BE_UNLESS_END>
    {
        jjtThis.init();
    }
}

void BeCondition():
{}
{
  LOOKAHEAD(<BE_IF_START>) BeIf()
  {
    popModeOptional(Mode.ELSE);
  } | LOOKAHEAD(<BE_UNLESS_START>) BeUnless()
}

void BeIfUnlessChain() #BeConditionChain:
{
  boolean hasElse;
}
{
    BeIf()
    {
      hasElse = popModeOptional(Mode.ELSE);
    }
    [ LOOKAHEAD(<BE_UNLESS_START>) 
    {
      if(hasElse)
        throw new IllegalStateException("Unexpected <unless>");
    }
    BeUnless()]
}

void BeIfUnlessChainOptional(Mode mode) #BeConditionChain:
{
}
{
  {
    pushMode(mode);
  }
  ( BeUnless() | BeIfUnlessChain() )
  {
    popMode(mode);
  }
}

void BeThen() #BeThen:
{}
{
    <BE_THEN_START> (LOOKAHEAD(<BE_IF_START> | <BE_UNLESS_START>) (BeCondition())+ | BeAction()) <BE_THEN_END>   
}

void BeThenImplicit() #BeThen:
{}
{
    (LOOKAHEAD(<BE_IF_START> | <BE_UNLESS_START>) (BeCondition())+ | BeAction())
    {
      jjtThis.setImplicit(true);
    }   
}

void BeElse() #BeElse:
{}
{
    <BE_ELSE_START> (LOOKAHEAD(<BE_IF_START> | <BE_UNLESS_START>) (BeCondition())+ | BeAction()) <BE_ELSE_END>   
}

void BeAction() :
{}
{
  (
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_UNION })
    ((UnionClause() | ExceptClause())
    Select())+
  | 
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_SELECT_UNION })
    (Select()
    (UnionClause() | ExceptClause()))+
  | 
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_COLUMN })
    (DerivedColumn())*
  |
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_WHERE })
    WhereClause()
  | 
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_ORDER })
    OrderByClause()
  |
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_ORDER_ELEM })
    (OrderingElement())+
  |
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_WHEN })
    (CaseWhen())+ 
  | 
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_JOIN })
    (JoinedTable())+ 
  | 
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_AND })
    (<KW_AND> BooleanTerm())?
  | 
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_OR })
    <KW_OR> BooleanExpression()
  | 
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_CONCAT })
    <OP_CONCAT> ConcatExpression()
  |
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_VALUE })
    PrimaryExpression()  
  |
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_STRING })
    StringContent()  
  |
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_GROUP })
    GroupByClause()
  |
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_GROUP_ELEM })
    (GroupingElement())+
  |
    LOOKAHEAD({ getMode() == Mode.CONDITIONAL_FROM })
    FromClause()
  | 
  	(SelectValue())*
  ) 
}

void BePlaceHolder() #BePlaceHolder:
{
Token t;
}
{
    t=< BE_PLACEHOLDER >
    {
      jjtThis.setRawPlaceHolder(t.image);
    }
}

void BeListPlaceHolder() #BeListPlaceHolder:
{
Token t;
}
{
    t=<BE_LIST_PLACEHOLDER>
    {
      jjtThis.setRawPlaceHolder(t.image);
    }
}

/***************************************************************
                   From fragment
***************************************************************/

void FromClause() #From :
{}
{
	<FROM> TableReference() (<COMMA> TableReference())*
}

void TableReference() :
{}
{
	TablePrimary() 
	(
        LOOKAHEAD( [BeIfStart()] JoinType() )
        (JoinedTable() |
         BeIfUnlessChainOptional(Mode.CONDITIONAL_JOIN)
        )
	)*
}

void TablePrimary() #TableRef :
{}
{
	( TableName() | NestedQuery() | BeCommonTag() )
	( BeCommonTag() )*
    [[<AS>
	{
	  jjtThis.setAsToken(true);
	}] IdentifierConstant() [DerivedColumnList()]]
}

void TableName() #TableName :
{}
{
  IdentifierConstant()
  [ <DOT>
  (
    BeCommonTag()
  | IdentifierConstant()
  ) ]
}

void DerivedColumnList() #ColumnList :
{}
{
  <LEFT_PAREN> IdentifierConstant() (<COMMA> IdentifierConstant() )* <RIGHT_PAREN>
}

void JoinedTable() #Join :
{}
{
    JoinType()
    TablePrimary()
    (
       JoinSpecification()|NamedColumnsJoin()
    )
}

void JoinSpecification() #JoinSpecification :
{}
{
    ( <ON> BooleanExpression() )
}

void NamedColumnsJoin() #NamedColumnsJoin :
{}
{
    <USING> <LEFT_PAREN> IdentifierConstant() (<COMMA> IdentifierConstant())* <RIGHT_PAREN> 
}

void JoinType() #JoinType :
{}
{
  (<INNER> {jjtThis.setType("INNER");}|
  (<LEFT> {jjtThis.setType("LEFT");} | <RIGHT> {jjtThis.setType("RIGHT");} | <FULL> {jjtThis.setType("FULL");}) (<OUTER>)?)?
  <JOIN>
}

/***************************************************************
                   Where fragment
***************************************************************/

void WhereClause() #Where :
{}
{
    < WHERE > BooleanExpression()
}

/***************************************************************
                   Grouping fragment
***************************************************************/

void GroupByClause() #GroupBy :
{}
{
    <GROUP> <BY>
    (
        LOOKAHEAD([BeIfStart()] GroupingElementType())
        (
            LOOKAHEAD(BeIfStart() GroupingElementType())
            (
                {
                    pushMode(Mode.CONDITIONAL_GROUP_ELEM);
                }
                BeCondition()
                {
                    popMode(Mode.CONDITIONAL_GROUP_ELEM);
                }
            )
        |   GroupingElement()
        )
    )+
}

// Used for lookahead in GroupByClause
void GroupingElementType() :
{}
{
    <CASE> | <NULL> | <CAST> | <COUNT> | <EXTRACT> | <POSITION> | <GROUPING_SETS> | <LEFT> | <RIGHT> | <INTERVAL> |
    <PLUS> | <MINUS> | <COMMA> | <LEFT_PAREN> | <BE_SQL_START> | <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL> |
    <BACKTICK_QUOTED> | <IDENTIFIER> | <SINGLE_QUOTE> | <E_SINGLE_QUOTE> | <DOUBLE_QUOTED> | <BE_PARAMETER_TAG_START> |
    <BE_SESSION_TAG_START> | <BE_SQL_VAR_START> | <BE_DICTIONARY_START> | <BE_PLACEHOLDER> 
}

void GroupingElement() #GroupingElement :
{}
{
    [<COMMA> { jjtThis.setPrefixComma(true);}]
    (ValueExpression() | GroupingSetsSpecification())
    [LOOKAHEAD(2) <COMMA> { jjtThis.setSuffixComma(true);}]
    
}

void GroupingSetsSpecification() #GroupingSetsSpecification :
{}
{
  <GROUPING_SETS> <LEFT_PAREN> GroupingSet() ( <COMMA> GroupingSet() )* <RIGHT_PAREN> 
}

void GroupingSet() #GroupingSet :
{}
{
  Cast() | FieldReference() | GroupingReferenceList()
}

void GroupingReferenceList() #ColumnList :
{}
{
  <LEFT_PAREN> [(Cast() | FieldReference()) (<COMMA> (Cast() | FieldReference()))*] <RIGHT_PAREN> 
}

/***************************************************************
                   Having fragment
***************************************************************/

void HavingClause() #Having :
{}
{
    < HAVING > BooleanExpression()
}

/***************************************************************
                   Ordering fragment
***************************************************************/

void OrderByClause() #OrderBy :
{}
{
    <ORDER> <BY> OrderingElement()
    (
        LOOKAHEAD([BeIfStart()] OrderingElementType())
        (
            LOOKAHEAD(BeIfStart() OrderingElementType())
            (
                {
                    pushMode(Mode.CONDITIONAL_ORDER_ELEM);
                }
                BeCondition()
                {
                    popMode(Mode.CONDITIONAL_ORDER_ELEM);
                }
            )
        |   OrderingElement()
        )
    )*
}

void OrderingElementType() :
{}
{
    <CASE> | <NULL> | <CAST> | <COUNT> | <EXTRACT> | <POSITION> | <LEFT> | <RIGHT> | <INTERVAL> |
    <PLUS> | <MINUS> | <COMMA> | <LEFT_PAREN> | <BE_SQL_START> | <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL> |
    <BACKTICK_QUOTED> | <IDENTIFIER> | <SINGLE_QUOTE> | <E_SINGLE_QUOTE> | <DOUBLE_QUOTED> | <BE_PARAMETER_TAG_START> |
    <BE_SESSION_TAG_START> | <BE_SQL_VAR_START> | <BE_DICTIONARY_START> | <BE_PLACEHOLDER> 
}

void OrderingElement() #OrderingElement :
{
    Token dir = null, nulls = null;
}
{
    [<COMMA>]
    (ValueExpression()) (dir=<ASC>|dir=<DESC>)? (nulls=<NULLS_FIRST>|nulls=<NULLS_LAST>)?
    {
        jjtThis.setDirectionToken(dir);
        jjtThis.setNullsToken(nulls);
    }
    [LOOKAHEAD(2) BeCommonTag()]
    [LOOKAHEAD(2) <COMMA>]
}

/***************************************************************
                   Limit fragment
***************************************************************/

void LimitClause() #Limit :
{
    Integer count, offset = 0;
}
{
  <LIMIT> [LOOKAHEAD(2) (offset = IntegerConstant() <COMMA>)] count = IntegerConstant()
  [<OFFSET> offset = IntegerConstant()]
  {
     jjtThis.setLimit(offset, count);
  }
}

/***************************************************************
                   Expressions
***************************************************************/

void ValueExpression():
{}
{
   Expression() 
}

// Case

void CaseSpecification() #Case :
{}
{
  <CASE> (CaseWhen() | ValueExpression() CaseWhen()) (
      BeIfUnlessChainOptional(Mode.CONDITIONAL_WHEN) |
      CaseWhen()
  )* (ElseClause())? <END>
}

void CaseWhen() #When :
{
  Token t;
}
{
  <WHEN> BooleanExpression() t=<THEN> ValueExpression()
  {jjtThis.setThenToken(t);}
}

void ElseClause() #CaseElse :
{}
{
  <ELSE> ValueExpression()
}

/***************************************************************
                   Boolean Expressions
***************************************************************/

void BooleanExpression() #BooleanExpression :
{
}
{
  	BooleanTerm()
  	(
      LOOKAHEAD( [BeIfStart()] <KW_OR> )
      (  
        BeIfUnlessChainOptional(Mode.CONDITIONAL_OR) 
      |
  	  <KW_OR> BooleanTerm()
  	  )
    )*  
}

void BooleanTerm() #BooleanTerm :
{
}
{
  	BooleanFactor()
  	(
  	  LOOKAHEAD( [BeIfStart()] <KW_AND> )
      (  
        BeIfUnlessChainOptional(Mode.CONDITIONAL_AND) 
      |
        <KW_AND> BooleanFactor()
      )
    )*      
}

void BooleanFactor() :
{}
{
  	( BooleanTest() |  BooleanNot() )
}

void BooleanNot() #BooleanNot :
{}
{
  ( <KW_NOT> | <NOT> ) BooleanTest()
}

void BooleanTest() :
//{ Token operator = null; }
{}
{
  	BooleanPrimary()
// Actually it's "IS [NOT] (TRUE|FALSE|UNKNOWN)", defer support as it's not used actually
//    [ (operator=<KW_IS> [operator=<KW_NOT>] BooleanTest()  { setOperator(jjtThis, operator); } ) #FunNode(5) ]
}

void BooleanPrimary() : {}
{
  Predicate() 
}

void ParenthesizedExpression() #Parenthesis : {}
{
  	<LEFT_PAREN> BooleanExpression() <RIGHT_PAREN>
}

void Predicate() :
{}
{
  ExistsPredicate()
| ComplexPredicate() 
}

void ComplexPredicate() #ComplexPredicate :
{
}
{
  RowValuePredicand()
  (
    ComparisonPredicatePart()
  | InPredicatePart()
  | BetweenPredicatePart()
  | NullPredicatePart()
  )?
}

void ExistsPredicate() #ExistsPredicate() :
{}
{
  < EXISTS > NestedQuery() 
}

void ComparisonPredicatePart() #FunNode(2) : { Token operator; }
{
	operator=CompOperator() RowValuePredicand() { setOperator(jjtThis, operator); }
}

Token CompOperator() : { Token op; }
{
  	op = <NE>        	{ return op; }
  | op = <EQ>           { return op; }
  | op = <ASSIGNMENT>   { return op; }
  |	op = <LT> 	        { return op; }
  |	op = <GT> 	        { return op; }
  |	op = <LE> 	        { return op; }
  |	op = <GE> 	        { return op; }
  | op = <LIKE>         { return op; }
  | op = <NOT_LIKE>     { return op; }
  | op = <REGEXP_MATCH> { return op; }
}
  
void RowValuePredicand() : {}
{
   ValueExpression()
// | <row value constructor predicand>					// @todo
}

void NullPredicatePart() #NullPredicate :
{
    Token isToken, notToken = null, nullToken;
}
{
    isToken=<KW_IS> (notToken=<KW_NOT>)? nullToken=<NULL>
    {
      jjtThis.setIsToken(isToken);
      jjtThis.setNotToken(notToken);
      jjtThis.setNullToken(nullToken);
    }
}

// BetweenPredicate

void BetweenPredicatePart() #BetweenPredicate : {}
{
	  <KW_BETWEEN>
	  ValueExpression()
	  <KW_AND>
	  ValueExpression() 
}

// InPredicate

void InPredicatePart() #InPredicate : {}
{
	  (<KW_NOT>
	  {
	    jjtThis.setInversed(true);
	  })? <KW_IN>
	  (
	    BeListPlaceHolder() |
	    BeParameterTag() |
	    BeDictionary() |
	    LOOKAHEAD((<LEFT_PAREN>)+ [BeIfStart()] <SELECT>) NestedQuery() |
	    InValueList()
	  )
}

void InValueList() #InValueList :
{}
{
	<LEFT_PAREN> (RowValuePredicand()) (<COMMA> RowValuePredicand())*   <RIGHT_PAREN>
}

void RowValueExpression() : {}									// @pending
{
	AnyConstant()
}


/***************************************************************
                   EXPRESSION
***************************************************************/

void Expression() : {}
{
    ConcatExpression()
}

void ConcatExpression() #ConcatExpression :
{}
{
  JsonExpression()
  (
      LOOKAHEAD( [BeIfStart()] <OP_CONCAT> )
      (  
        BeIfUnlessChainOptional(Mode.CONDITIONAL_CONCAT) 
      |
      <OP_CONCAT> JsonExpression()
      )
    
  )*
}

void JsonExpression() : { Token op; }
{
  BitOrExpression()
  (
    ( (op=<GET_FIELD> | op=<GET_FIELD_TXT> | op=<EXTRACT_PATH> |op=<EXTRACT_PATH_TXT>) BitOrExpression()
      {
          setOperator(jjtThis, op);
      }
    ) #FunNode(2)
  )*
}

void BitOrExpression() : { Token op; }
{
  BitAndExpression()
  (
    ( op=<BIT_OR> BitAndExpression()
      {
          setOperator(jjtThis, op);
      }
    ) #FunNode(2)
  )*
}

void BitAndExpression() : { Token op; }
{
  AdditiveExpression()
  (
    ( op=<BIT_AND> AdditiveExpression()
      {
          setOperator(jjtThis, op);
      }
    ) #FunNode(2)
  )*
}

void AdditiveExpression() : { Token op; }
{
  MultiplicativeExpression()
  (
    LOOKAHEAD(2)
    ( (op=<PLUS> | op=<MINUS>) MultiplicativeExpression()
      {
          setOperator(jjtThis, op);
      }
    ) #FunNode(2)
  )*
}

void MultiplicativeExpression() : { Token op; }
{
  UnaryExpression()
  (
    ( op=<MUL> UnaryExpression()
      {
        setOperator(jjtThis, op);
      }
    ) #FunNode(2)
        |
    ( op=<DIV> UnaryExpression()
      {
        setOperator(jjtThis, op);
      }
    ) #FunNode(2)
        |
    ( op=<MOD> UnaryExpression()
      {
        setOperator(jjtThis, op);
      }
    ) #FunNode(2)
  )*
}

void UnaryExpression() : { Token op; }
{
  ( op=<PLUS> UnaryExpression())
|
  ( op=<MINUS> UnaryExpression()
    {
          setOperator(jjtThis, op);
          setOperator(jjtThis, "u-"); // tokenImage[MINUS]);
    }
  ) #FunNode(1)
|
  PrimaryExpression()
}

void PrimaryExpression() :
{}
{
        LOOKAHEAD(<LEFT_PAREN> [BeIfStart()] <SELECT>) NestedQuery()
    |   LOOKAHEAD(2) Function() [(WindowSpecification()) #WindowFunction(2)]
    |   Interval()
    |   LOOKAHEAD(StringConstant() <DOUBLE_COLON>) IntervalSuffix()
    |   ParenthesizedExpression()
    |   LOOKAHEAD(2) Count() [(WindowSpecification()) #WindowFunction(2)]
    |   CaseSpecification()
    |   AnyConstant()
    |   ReplacementParameter()
    |   Cast()
    |   Extract()
    |   Position()
    |   { pushMode(Mode.CONDITIONAL_VALUE); } BeIfUnlessChain() { popMode(Mode.CONDITIONAL_VALUE); } // BE
    |   BeSql() //BE
    |   BeCommonTag() //BE
}

/***************************************************************
                   Function call
***************************************************************/

void Function() #FunNode :
{
    Token operator;
    boolean agg = false;
}
{
	(operator=<IDENTIFIER>|operator=<RIGHT>|operator=<LEFT>) 
    {
        setOperator(jjtThis, operator);
    }
    <LEFT_PAREN> [<DISTINCT> { jjtThis.setDistinct(true); agg = true; }]
    ArgumentList(jjtThis, jjtThis.getFunction())
    [OrderByClause() { agg = true; }] <RIGHT_PAREN>
    {
        if(agg && getFunction().getPriority() != Function.AGGREGATE_FUNCTION_PRIORITY)
        {
            error(getFunction().getName() + " is not aggregate function");
        }
    }
}

void ArgumentList(AstFunNode node, Function function) :
{
    int count = 0;
    String errorStr = "";
}
{
  {
    setFunction(function);
  }
	((LOOKAHEAD({ getFunction() != null && getFunction().getName().equalsIgnoreCase("if") })
	   BooleanExpression() | Expression())
	   { count++; } (<COMMA> Expression() { count++; } )*)?
    {
        int minNumberOfParams = function.minNumberOfParams();
        int maxNumberOfParams = function.maxNumberOfParams();
        if( count < minNumberOfParams || ( maxNumberOfParams != -1 && count > maxNumberOfParams) ) 
        {
            errorStr = "Function \"" + function.getName() +"\" requires "
                            + ( minNumberOfParams == maxNumberOfParams ? minNumberOfParams
                            : "from " + minNumberOfParams + " to " + maxNumberOfParams ) + " parameter";
            if( minNumberOfParams != maxNumberOfParams || minNumberOfParams !=1 )
                errorStr += "s";

            error(errorStr);
        }
    }
}

void WindowFunction() #WindowFunction :
{}
{
   ( Count() | Function() ) WindowSpecification()
}

void WindowSpecification() #WindowSpecification :
{}
{
   ( <OVER> (IdentifierConstant() | (<LEFT_PAREN> [IdentifierConstant()] [PartitionByClause()] 

[OrderByClause()] [WindowFrameClause()]) <RIGHT_PAREN>) )
}

void WindowFrameClause() #FrameClause : { Token unit; }
{
   ( unit=<ROWS> | unit=<RANGE> )
   {
     jjtThis.setUnit(unit.image);
   }
   ( WindowFrameStart() | WindowFrameBetween() )
}

void WindowFrameStart() #FrameStart : { Token p, s; }
{
   ( p=<UNBOUNDED_PRECEDING> | p=<CURRENT_ROW> )
   {
     jjtThis.setPrefix(p.image);
   }   
|  ValueExpression() s=<PRECEDING>
   {
     jjtThis.setSuffix(s.image);
   }
}

void WindowFrameBetween() #FrameBetween :
{}
{
   <KW_BETWEEN> WindowFrameBound() <KW_AND> WindowFrameBound()
}

void WindowFrameBound() #FrameBound : { Token p, s; }
{
   ( p=<CURRENT_ROW> | p=<UNBOUNDED_PRECEDING> | p=<UNBOUNDED_FOLLOWING> )
   {
     jjtThis.setPrefix(p.image);
   }   
|  ValueExpression() ( s=<PRECEDING> | s=<FOLLOWING> )
   {
     jjtThis.setSuffix(s.image);
   }
}

void Cast() #Cast : { Token type, num, scale; }
{
    <CAST> <LEFT_PAREN> 
    Expression() <AS> type=<IDENTIFIER>
    {
        jjtThis.setDataType(type.image);
    }
    ( 
      <LEFT_PAREN> num=<INTEGER_LITERAL> { jjtThis.setSize(Integer.valueOf(num.image)); }
      [ <COMMA> scale=<INTEGER_LITERAL> { jjtThis.setScale(Integer.valueOf(scale.image)); } ]
      <RIGHT_PAREN>
    )?
    <RIGHT_PAREN>
}

void Count() #Count :
{}
{
  <COUNT> <LEFT_PAREN> 
  (
    <MUL>
    {
      jjtThis.setAny();
    } | Expression() | <DISTINCT> Expression() (<COMMA> Expression() )*
    {
      jjtThis.setDistinct();
    }
  )
  <RIGHT_PAREN>
}

void Extract() #Extract : { Token dateField; }
{
    <EXTRACT> <LEFT_PAREN> dateField=<IDENTIFIER>
    {
        jjtThis.setDateField(dateField.image);
    }
    <FROM> Expression() <RIGHT_PAREN>
}

void Position() #Position : 
{}
{
    <POSITION> <LEFT_PAREN> Expression() <KW_IN> Expression() <RIGHT_PAREN>
}

String Identifier() :
{
    Token t1;
}
{
    /* BE-specific keywords can be valid SQL identifiers */
    (t1=<DOUBLE_QUOTED> |
    t1=<BACKTICK_QUOTED> |
    t1=<IDENTIFIER> | t1=<COUNT>
    )
    {
        return t1.image;
    }
}

void AnyConstant() :
{}
{
  BePlaceHolder()
| FieldReference()
| StringConstant()
| NumericConstant()
| SpecialConstant()
}

void SpecialConstant() #SpecialConstant :
{
    Token t;
}
{
    t = < NULL >
    {
        jjtThis.setValue(AstSpecialConstant.Special.NULL);
    }
}

void ReplacementParameter() #ReplacementParameter :
{
    Token t;
}
{
    t = < REPLACEMENT_PARAMETER >
    {
        jjtThis.setValue(t.image);
    }
}

void FieldReference() #FieldReference :
{}
{
  IdentifierConstant()
  [ < DOT >
  (
    BeCommonTag()
  | IdentifierConstant()
  ) ]
}

void IdentifierConstant() #IdentifierConstant :
{
    String value = null;
}
{
    value=Identifier()
    {
        jjtThis.setValue(value);
    }
}

void StringConstant() #StringConstant :
{}
{   
    (<E_SINGLE_QUOTE> { jjtThis.setEscape(true); } | <SINGLE_QUOTE>)
    StringContent()
    <ENDING_SINGLE_QUOTE>
}
void StringContent() :
{}
{
    (StringPart() | BeSqlSubQuery() | BeCommonTag() | BePlaceHolder() | BeListPlaceHolder() |
    {
        pushMode(Mode.CONDITIONAL_STRING);
    }
    BeCondition()
    {
        popMode(Mode.CONDITIONAL_STRING);
    })*
}

void StringPart() #StringPart :
{
  Token t;
}
{
    (
      t = <STRING_PART> | t = <E_STRING_PART> | t = <STR_LT>
    )
    {
        jjtThis.setContent(t.image, true);
    }
}

void Interval() #Interval :
{}
{
  <INTERVAL> StringConstant()
}

void IntervalSuffix() #Interval :
{}
{
  StringConstant() <DOUBLE_COLON> <INTERVAL>
}

void NumericConstant() #NumericConstant :
{
    Number value;
}
{
    value = RealConstant() 
    {
        jjtThis.setValue(value);
    }
}

Number RealConstant() :
{
    Token t;
    Number value;
}
{
    (value=IntegerConstant()
    {
        return value;
    }
    |
    t=<FLOATING_POINT_LITERAL>
    {
        try 
        {
            value = Double.valueOf(t.image);
        } 
        catch (NumberFormatException e) 
        {
            value = null;
            error("Can't parse \"" + t.image + "\"");
        }
        
            return value;
    })
}

Integer IntegerConstant() :
{
    Token t;
    Integer value;
}
{
    t=<INTEGER_LITERAL>
    {
        try 
        {
            value = Integer.valueOf(t.image);
        } 
        catch (NumberFormatException e) 
        {
            value = null;
            error("Can't parse \"" + t.image + "\"");
        }
        
        return value;
    }
}
